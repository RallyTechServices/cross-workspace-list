<!DOCTYPE html>
<html>
<head>
    <title>Cross Workspace List</title>
    <!--  (c) 2016 CA Technologies.  All Rights Reserved. -->
    <!--  Build Date: Mon Jul 04 2016 13:52:53 GMT-0600 (MDT) -->
    
    <script type="text/javascript">
        var APP_BUILD_DATE = "Mon Jul 04 2016 13:52:53 GMT-0600 (MDT)";
        var BUILDER = "kcorkan";
        var CHECKSUM = 458014888440;
    </script>
    
    <script type="text/javascript" src="/apps/2.1/sdk.js"></script>

    <script type="text/javascript">
        Rally.onReady(function() {
             
/**
 * A link that pops up a version dialog box
 */

Ext.define('Rally.technicalservices.InfoLink',{
    extend: 'Rally.ui.dialog.Dialog',
    alias: 'widget.tsinfolink',
    
    /**
     * @cfg {String} informationHtml
     * Additional text to be displayed on the popup dialog (for exmaple,
     * to add a description of the app's use or functionality)
     */
    informationHtml: null,
    
    /**
     * 
     * cfg {String} title
     * The title for the dialog box
     */
    title: "Build Information",
    
    defaults: { padding: 5, margin: 5 },

    closable: true,
     
    draggable: true,

    autoShow: true,
   
    width: 350,
    
    informationalConfig: null,
    
    items: [{xtype:'container', itemId:'information' }],
    
    initComponent: function() {
        var id = Ext.id(this);
        this.title =  "<span class='icon-help'> </span>" + this.title;
        this.callParent(arguments);
    },
    
    _generateChecksum: function(string){
        var chk = 0x12345678,
            i;
        string = string.replace(/var CHECKSUM = .*;/,"");
        string = string.replace(/var BUILDER = .*;/,"");
        string = string.replace(/\s/g,"");  //Remove all whitespace from the string.
       
        for (i = 0; i < string.length; i++) {
            chk += (string.charCodeAt(i) * i);
        }
   
        return chk;
    },
    
    _checkChecksum: function(container) {
        var deferred = Ext.create('Deft.Deferred');
        var me = this;
        
        Ext.Ajax.request({
            url: document.URL,
            params: {
                id: 1
            },
            success: function (response) {
                text = response.responseText;
                if ( CHECKSUM ) {
                    var stored_checksum = me._generateChecksum(text);
                    if ( CHECKSUM !== stored_checksum ) {
                        deferred.resolve(false);
                        return;
                    }
                }
                deferred.resolve(true);
            }
        });
        
        return deferred.promise;
    },
    
    _addToContainer: function(container){
        var config = Ext.apply({
            xtype:'container',
            height: 200,
            overflowY: true
        }, this.informationalConfig);
        
        container.add(config);
    },
    
    afterRender: function() {
        var app = Rally.getApp();
        
        if ( !Ext.isEmpty( this.informationalConfig ) ) {
            var container = this.down('#information');
            this._addToContainer(container);
            
        }
        
        if (! app.isExternal() ) {
            this._checkChecksum(app).then({
                scope: this,
                success: function(result){
                    if ( !result ) {
                        this.addDocked({
                            xtype:'container',
                            cls: 'build-info',
                            dock: 'bottom',
                            padding: 2,
                            html:'<span class="icon-warning"> </span>Checksums do not match'
                        });
                    }
                },
                failure: function(msg){
                    console.log("oops:",msg);
                }
            });
        } else {
            this.addDocked({
                xtype:'container',
                cls: 'build-info',
                padding: 2,
                dock: 'bottom',
                html:'... Running externally'
            });
        }
        this.callParent(arguments);
    },
    
    beforeRender: function() {
        var me = this;
        this.callParent(arguments);

        if (this.informationHtml) {
            this.addDocked({
                xtype: 'component',
                componentCls: 'intro-panel',
                padding: 2,
                html: this.informationHtml,
                doc: 'top'
            });
        }
        
        this.addDocked({
            xtype:'container',
            cls: 'build-info',
            padding: 2,
            dock:'bottom',
            html:"This app was created by the CA AC Technical Services Team."
        });
        
        if ( APP_BUILD_DATE ) {
            this.addDocked({
                xtype:'container',
                cls: 'build-info',
                padding: 2,
                dock: 'bottom',
                html: Ext.String.format("Build date/time: {0} ({1})",
                    APP_BUILD_DATE,
                    BUILDER)
            });
        }
    }
});

/*
 */
Ext.define('Rally.technicalservices.Logger',{
    constructor: function(config){
        Ext.apply(this,config);
    },
    log: function(args){
        var timestamp = "[ " + Ext.util.Format.date(new Date(), "Y-m-d H:i:s.u") + " ]";
        //var output_args = arguments;
        //output_args.unshift( [ "[ " + timestamp + " ]" ] );
        //output_args = Ext.Array.push(output_args,arguments);
        
        var output_args = [];
        output_args = Ext.Array.push(output_args,[timestamp]);
        output_args = Ext.Array.push(output_args, Ext.Array.slice(arguments,0));

        window.console && console.log.apply(console,output_args);
    }

});

//Ext.define('Rally.technicalservices.artifactCopier',{
//    logger: new Rally.technicalservices.Logger(),
//
//    mixins: {
//        observable: 'Ext.util.Observable'
//    },
//    /**
//     * Passed config:
//     *    fieldsToCopy: ['Name','Owner','Description'],
//     *    linkField: this.getSetting('link_field'),
//     */
//
//    constructor: function(config){
//        Ext.apply(this,config);
//
//        this.mixins.observable.constructor.call(this, config);
//
//        this.addEvents(
//            'artifactcreated',
//            'artifactupdated',
//            'copyerror',
//            'updateerror',
//            'validationfailed',
//            'updatewarning'
//        );
//    },
//
//    copy: function(targetWorkspace, targetProject, artifact){
//        this._getModel(targetWorkspace, targetProject, artifact.get('_type')).then({
//            scope: this,
//            success: function(model){
//                var validation_issues = this._validateFields(this.fieldsToCopy, model, artifact);
//                if (validation_issues && validation_issues.length > 0 ){
//                    this.fireEvent('copyerror', validation_issues);
//                } else {
//                    this._createArtifact(model,artifact, targetWorkspace, targetProject);
//                }
//            },
//            failure: function(obj){
//                this.fireEvent('copyerror', this.buildErrorMessage('Error getting the model: ', obj));
//            }
//        });
//    },
//    updateFromLinkedArtifact: function(artifact_to_be_updated){
//
//        var link = artifact_to_be_updated.get(this.linkField),
//            matches = /<a.*href="\/#\/(\d+).*\/detail\/userstory\/(\d+)">(.*)<\/a>/.exec(link),
//            objectID = null,
//            projectOid = null,
//            store_context = null,
//            friendly_text = null;
//
//        if (!matches){
//            this.fireEvent('updateerror', this.buildInvalidLinkData(artifact_to_be_updated));
//            return;
//        }
//
//        if (matches){
//            objectID = matches[2] || null;
//            projectOid =matches[1] || null;
//            store_context = this._getLinkedContext(projectOid);
//            friendly_text = matches[3] || 'Unknown';
//        }
//
//        var filters = [{property: 'ObjectID', value: objectID}];
//
//        if (store_context.workspace == null || store_context.project==null){
//            this.fireEvent('updateerror', this.buildNoLinkedContextMessage(artifact_to_be_updated,friendly_text));
//            return;
//        }
//        console.log('_getLinkedArtifactInfo', objectID,store_context);
//
//        var store = Ext.create('Rally.data.wsapi.Store',{
//            fetch: this.fieldsToCopy,
//            filters: filters,
//            context: store_context,
//            model: 'hierarchicalrequirement'
//        });
//        store.load({
//            scope: this,
//            callback: function(records, operation){
//                if (operation.wasSuccessful()){
//                    if (records && records.length > 0) {
//                        this._updateArtifact(artifact_to_be_updated, records[0]);
//                    } else {
//                        this.fireEvent('updatewarning', Ext.String.format('No record found for linked object {0} (ObjectID = ).  The item may have been moved or deleted.',friendly_text, objectID));
//                    }
//                } else {
//                    this.fireEvent('updateerror', this.buildErrorMessage(Ext.String.format('Error loading linked object {0}',friendly_text), operation));
//                }
//            }
//        });
//    },
//    _getLinkedContext: function(projectOid){
//
//        var project = null, workspace = null;
//        Ext.Array.forEach(this.context.getPermissions().userPermissions, function(permission) {
//            if(permission.Workspace) {
//
//                if (projectOid == Rally.util.Ref.getOidFromRef(permission._ref)){
//                    project = permission._ref;
//                    workspace = permission.Workspace;
//                    return false;
//                }
//            }
//        });
//        return {workspace: workspace, project: project};
//    },
//    _updateArtifact: function(artifact_to_be_updated, source_artifact) {
//
//        _.each(this.fieldsToCopy, function (f) {
//            artifact_to_be_updated.set(f, this._getFieldValue(source_artifact, f));
//        }, this);
//
//        this.logger.log('_updateArtifact (dirty)', artifact_to_be_updated, source_artifact, this.fieldsToCopy);
//        artifact_to_be_updated.save({
//            scope: this,
//            callback: function (record, operation) {
//                this.logger.log('_updateArtifact callback returned',record, operation);
//                if (operation.wasSuccessful()) {
//                    this.fireEvent('artifactupdated', record);
//                } else {
//                    this.fireEvent('updateerror', this.buildErrorMessage(Ext.String.format('Error updating artifact {0}', artifact_to_be_updated.get('FormattedID')), operation));
//                }
//            }
//        });
//    },
//    _createArtifact: function(model, artifact, targetWorkspace, targetProject){
//
//        var fields = {};
//        _.each(this.fieldsToCopy, function(f){
//            fields[f] = this._getFieldValue(artifact, f);
//        }, this);
//        fields[this.linkField] = this._getLinkValue(artifact, this.context.getWorkspace(), this.context.getProject());
//
//        this.logger.log('_createArtifact', fields);
//        var record = Ext.create(model, fields);
//        record.save({
//            scope: this,
//            callback: function(record, operation){
//                if (operation.wasSuccessful()){
//                    this.fireEvent('artifactcreated',record);
//                    this._linkArtifacts(artifact, record, targetWorkspace, targetProject);
//                } else {
//                    this.logger.log('_createArtifact error (operation, artifact, new record)', operation, artifact, record);
//                    this.fireEvent('copyerror',this.buildErrorMessage('Error saving artifact', operation));
//                }
//            }
//        });
//    },
//    _validateFields: function(fields_to_copy, model, artifact){
//        var missing_fields = [];
//        if (!model.getField(this.linkField)){
//            return this.buildLinkFieldMissingMessage(artifact.getField(this.linkField).displayName);
//        }
//
//        _.each(fields_to_copy, function(f){
//            if (!model.getField(f)){
//                missing_fields.push(artifact.getField(f).displayName);
//            }
//        });
//        if (missing_fields.length > 0){
//            return this.buildFieldValidationErrorMessage(missing_fields);
//        }
//        return null;
//    },
//    _linkArtifacts: function(artifact, newArtifact, targetWorkspace, targetProject){
//           this.logger.log('_linkArtifacts')
//           artifact.set(this.linkField,this._getLinkValue(newArtifact, targetWorkspace, targetProject));
//           artifact.save({
//               scope: this,
//               callback: function (record, operation){
//                    if (operation.wasSuccessful()){
//                        this.fireEvent('artifactupdated',record);
//                    } else {
//                        this.fireEvent('updateerror',this.buildErrorMessage('Error updating linked field.',operation));
//                    }
//                }
//           });
//    },
//     _getLinkValue: function(artifact, workspace, project){
//        var workspaceName = workspace.Name,
//            projectName = project.Name,
//            link_text = Ext.String.format('[{0}][{1}] {2}',workspaceName, projectName, artifact.get('FormattedID'));
//
//         return Rally.nav.DetailLink.getLink({
//            record: artifact,
//            text: link_text
//        });
//    },
//    _getFieldValue: function(artifact, field){
//        console.log('--',artifact.get(field), artifact.getField(field));
//        var field_obj = artifact.getField(field);
//        if (field_obj && field_obj.attributeDefinition && field_obj.attributeDefinition.AttributeType == 'OBJECT'){
//            return artifact.get(field)._ref || null;
//        }
//        return artifact.get(field) || null;
//    },
//    _getModel: function(targetWorkspace, targetProject, modelType){
//        var deferred = Ext.create('Deft.Deferred');
//        Rally.data.ModelFactory.getModel({
//            type: modelType,
//            context: {
//                workspace: targetWorkspace._ref,
//                project: targetProject._ref
//            },
//            scope: this,
//            success: function(model) {
//                deferred.resolve(model);
//            },
//            failure: function(obj){
//                deferred.reject(obj);
//            }
//        });
//        return deferred;
//    },
//    buildErrorMessage: function(msg, operation){
//        return Ext.String.format('{0}:  [{1}]',msg, operation.error.errors.join(','));
//    },
//    buildLinkFieldMissingMessage: function(field){
//         return Ext.String.format('Validation Error:  Link field [{0}] is missing in the destination.',field);
//    },
//    buildFieldValidationErrorMessage: function(fields){
//        return Ext.String.format("Validation Error(s):  Fields to copy are missing from the destination: [{0}]",fields.join(','));
//    },
//    buildNoLinkedContextMessage: function(artifact, friendly_text){
//        return Ext.String.format("No valid context found for {0}, needed to update {1}.  Please verify that you have editor or higher permissions to the linked project and workspace.", friendly_text, artifact.get('FormattedID'));
//    },
//    buildInvalidLinkData: function(artifact){
//        return Ext.String.format("Could not get valid linked object information from {0}.  Please inspect the revision history to see if the data for the link field {1} has changed.", artifact.get('FormattedID'), this.linkField);
//    }
//});

/**
 * A dialog that displays artifacts to choose from and a tree
 * of workspace/projects to use as the target to copy to.
 *
 *     @example
 *     Ext.create('Rally.technicalservices.dialog.CopyDialog', {
 *         artifactTypes: ['userstory', 'portfolioitem/feature'],
 *         autoShow: true,
 *         height: 250,
 *         title: 'Choose User Stories',
 *         listeners: {
 *             artifactchosen: function(dialog, selectedRecord){
 *                 Ext.Msg.alert('Chooser', selectedRecord.get('Name') + ' was chosen');
 *             },
 *             scope: this
 *         }
 *      });
 */
Ext.define('Rally.technicalservices.dialog.CopyDialog', {
    requires: [
        'Ext.data.Store',
        'Rally.data.ModelFactory',
        'Rally.data.wsapi.Filter',
        'Rally.ui.Button',
        'Rally.ui.EmptyTextFactory',
        'Rally.ui.grid.Grid',
        'Rally.ui.selection.CheckboxModel',
        'Rally.util.Ref'
    ],
    extend: 'Rally.ui.dialog.Dialog',
    alias: 'widget.rallycopydialog',

    clientMetrics: [
        {
            method: '_search',
            description: 'chooser search performed'
        },
        {
            event: 'artifactchosen',
            description: 'artifact chosen'
        }
    ],

    height: 400,
    width: 600,
    layout: 'fit',
    closable: true,
    draggable: true,

    config: {
        /**
         * @cfg {String}
         * Title to give to the dialog
         */
        title: 'Choose an Artifact',
        /**
         * @cfg {Array} (required)
         * List of artifact types to allow the user to choose from
         */
        artifactTypes: [],
        /**
         * @cfg {Boolean}
         * Allow multiple selection or not
         */
        multiple: false,

        /**
         * @cfg {Object}
         * An {Ext.data.Store} config object used when building the grid
         * Handy when you need to limit the selection with store filters
         */
        storeConfig: {
            context: {
                project: null
            },
            sorters: [
                {
                    property: 'FormattedID',
                    direction: 'DESC'
                }
            ]
        },

        /**
         * @cfg {Ext.grid.Column}
         * List of columns that will be used in the chooser
         */
        columns: [
            {
                text: 'ID',
                dataIndex: 'FormattedID',
                renderer: _.identity
            },
            'Name'
        ],

        /**
         * @cfg {String}
         * Text to be displayed on the button when selection is complete
         */
        selectionButtonText: 'Done',

        /**
         * @cfg {Object}
         * The grid configuration to be used when creative the grid of items in the dialog
         */
        gridConfig: {},

        /**
         * @deprecated
         * @cfg {String}
         * The ref of a record to select when the chooser loads
         * Use selectedRecords instead
         */
        selectedRef: undefined,

        /**
         * @cfg {String}|{String[]}
         * The ref(s) of items which should be selected when the chooser loads
         */
        selectedRecords: undefined,

        /**
         * @cfg {Array}
         * The records to select when the chooser loads
         */
        initialSelectedRecords: undefined,

        /**
         * @private
         * @cfg userAction {String} (Optional)
         * The client metrics action to record when the user makes a selection and clicks done
         */

        /**
         * @cfg showRadioButtons {Boolean}
         */
        showRadioButtons: true
    },

    constructor: function(config) {
        this.mergeConfig(config);

        this.callParent([this.config]);
    },

    selectionCache: [],

    initComponent: function() {
        this.callParent(arguments);

        this.addEvents(
            /**
             * @event artifactchosen
             * Fires when user clicks done after choosing an artifact
             * @param {Rally.ui.dialog.ArtifactChooserDialog} source the dialog
             * @param {Rally.data.wsapi.Model}| {Rally.data.wsapi.Model[]} selection selected record or an array of selected records if multiple is true
             */
            'artifactchosen'
        );

        this.addCls(['chooserDialog', 'chooser-dialog']);
    },

    destroy: function() {
        this._destroyTooltip();
        this.callParent(arguments);
    },

    beforeRender: function() {
        this.callParent(arguments);

        this.addDocked({
            xtype: 'toolbar',
            dock: 'bottom',
            padding: '0 0 10 0',
            layout: {
                type: 'hbox',
                pack: 'center'
            },
            ui: 'footer',
            items: [
                {
                    xtype: 'rallybutton',
                    itemId: 'doneButton',
                    text: this.selectionButtonText,
                    cls: 'primary rly-small',
                    scope: this,
                    disabled: true,
                    userAction: 'clicked done in dialog',
                    handler: function() {
                        this.fireEvent('artifactchosen', this, this.getSelectedRecords());
                        this.close();
                    }
                },
                {
                    xtype: 'rallybutton',
                    text: 'Cancel',
                    cls: 'secondary rly-small',
                    handler: this.close,
                    scope: this,
                    ui: 'link'
                }
            ]
        });

        var top_items = [];
                
        //if (this.introText) {
        //    top_items.push({
        //        xtype: 'component',
        //        componentCls: 'intro-panel',
        //        padding: 5,
        //        html: this.introText
        //    });
        //}
        
        var picker = Ext.create('Rally.ui.picker.project.ProjectPicker',{
            itemId: 'project_picker',
            fieldLabel:this.introText,
            labelAlign: 'top',
            width: '100%',
            dock: 'top',
            border: false,
            padding: '0 0 10px 0',
            showMostRecentlyUsedProjects: true,
            listeners: {
                change: function(picker,record,options) {
                    this.target_project = picker.getSelectedRecord().getData();
                    this.target_workspace = this.target_project.Workspace;

                    this._enableDoneButton();
                },
                scope: this
            }
        });

        this.addDocked(picker);
       // top_items.push(picker);
        
        this.addDocked({
            xtype:'container',
            items:top_items
        });

        this.addDocked({
            xtype: 'toolbar',
            itemId: 'searchBar',
            dock: 'top',
            border: false,
            padding: '0 0 10px 0',
            items: this.getSearchBarItems()
        });

        this.buildGrid();

        this.selectionCache = this.getInitialSelectedRecords() || [];
    },

    /**
     * Get the records currently selected in the dialog
     * {Rally.data.Model}|{Rally.data.Model[]}
     */
    getSelectedRecords: function() {
        var selectedRecords = this.multiple ? this.selectionCache : this.selectionCache[0];
        
        var selectedValue = {
            selectedRecords: selectedRecords,
            targetProject: this.target_project,
            targetWorkspace: this.target_workspace
        };

        return selectedValue;
    },

    getGridModels: function() {
        return this.artifactTypes;
    },

    getSearchBarItems: function() {
        return [
            {
                xtype: 'triggerfield',
                cls: 'rui-triggerfield chooser-search-terms',
                emptyText: 'Search Keyword or ID',
                enableKeyEvents: true,
                flex: 1,
                itemId: 'searchTerms',
                listeners: {
                    keyup: function (textField, event) {
                        if (event.getKey() === Ext.EventObject.ENTER) {
                            this._search();
                        }
                    },
                    afterrender: function (field) {
                        field.focus();
                    },
                    scope: this
                },
                triggerBaseCls: 'icon-search chooser-search-icon'
            }
        ];
    },

    getStoreFilters: function() {
        return [];
    },

    buildGrid: function() {
        if (this.grid) {
            this.grid.destroy();
        }

        var me = this;
        var selectionConfig = {
            mode: this.multiple ? 'SIMPLE' : 'SINGLE',
            allowDeselect: true
        };
        this.grid = Ext.create('Rally.ui.grid.Grid', Ext.Object.merge({
            autoAddAllModelFieldsAsColumns: false,
            columnCfgs: this.columns,
            enableEditing: false,
            enableColumnHide: false,
            enableColumnMove: false,
            model: this.getGridModels(),
            selModel: this.showRadioButtons || this.multiple ? Ext.create('Rally.ui.selection.CheckboxModel', Ext.apply(selectionConfig, {
                enableKeyNav: false,
                isRowSelectable: function (record) {
                    return me._isArtifactEditable(record);
                }
            })) : Ext.create('Ext.selection.RowModel', selectionConfig),
            showRowActionsColumn: false,
            storeConfig: this._getStoreConfig(),
            viewConfig: {
                emptyText: Rally.ui.EmptyTextFactory.get('defaultText'),
                publishLoadMessages: false,
                getRowClass: function (record) {
                    return Rally.util.Test.toBrowserTestCssClass('row', record.getId()) + (me._isArtifactEditable(record) ? ''  : ' disabled-row');
                }
            }
        }, this.config.gridConfig));
        this.mon(this.grid, {
            beforeselect: this._onGridSelect,
            beforedeselect: this._onGridDeselect,
            load: this._onGridLoad,
            scope: this
        });
        this.add(this.grid);
        this._onGridReady();
    },

    _addTooltip: function() {
        this._destroyTooltip();
        this.tooltip = Ext.create('Rally.ui.tooltip.ToolTip', {
            target: this.grid.getEl(),
            html: 'You don\'t have permission to edit this item.',
            delegate: '.disabled-row',
            anchor: 'top',
            showDelay: 0,
            showOnClick: true
        });
    },

    _destroyTooltip: function() {
        if (this.tooltip) {
            this.tooltip.destroy();
        }
    },

    _getStoreConfig: function() {
        var storeConfig = _.cloneDeep(this.getInitialConfig().storeConfig);

        if (this._getSearchTerms()) {
            storeConfig.search = this._getSearchTerms();
        }

        storeConfig.filters = (storeConfig.filters || []).concat(this.getStoreFilters());
        return storeConfig;
    },

    _enableDoneButton: function() {
        
        if ( this.target_project && this.selectionCache.length > 0 ) {
            this.down('#doneButton').setDisabled(false);
        }
    },

    _findRecordInSelectionCache: function(record){
        return _.findIndex(this.selectionCache, function(cachedRecord) {
            return cachedRecord.get('_ref') === record.get('_ref');
        });
    },

    _onGridSelect: function(selectionModel, record) {
        if (!this._isArtifactEditable(record)) {
            return;
        }

        var index = this._findRecordInSelectionCache(record);
        if (index === -1) {
            if (!this.multiple) {
                this.selectionCache = [];
            }
            this.selectionCache.push(record);
        }

        this._enableDoneButton();
    },

    _onGridDeselect: function(selectionModel, record) {
        var index = this._findRecordInSelectionCache(record);
        if (index !== -1) {
            this.selectionCache.splice(index, 1);
        }

        this._enableDoneButton();
    },

    _onGridReady: function() {
        if (!this.grid.rendered) {
            this.mon(this.grid, 'afterrender', this._onGridReady, this, {single: true});
            return;
        }

        if (this.grid.getStore().isLoading()) {
            this.mon(this.grid, 'load', this._onGridReady, this, {single: true});
            return;
        }

        this._onGridLoad();
        this.center();
    },

    _isArtifactEditable: function(record) {
        return Rally.environment.getContext().getPermissions().isProjectEditor(record.get('Project'));
    },

    _onGridLoad: function() {
        var defaultSelection = Ext.Array.from(this.selectedRef || this.selectedRecords);
        if (defaultSelection.length) {
            var selectedRecords = _.compact(_.map(defaultSelection, function(ref) {
                var recordIndex = this.grid.getStore().find('_ref', ref);
                return recordIndex >= 0 ? this.grid.getStore().getAt(recordIndex) : null;
            }, this));
            if(selectedRecords.length) {
                this.grid.getSelectionModel().select(selectedRecords);
            }
        } else {
            var store = this.grid.store;
            var records = [];

            _.each(this.selectionCache, function(record) {
                var recordIndex = store.find('_ref', record.get('_ref'));

                if (recordIndex !== -1) {
                    var storeRecord = store.getAt(recordIndex);
                    records.push(storeRecord);
                }
            });

            if (records.length) {
                this.grid.getSelectionModel().select(records);
            }
        }

        this._addTooltip();
        if (Rally.BrowserTest) {
            Rally.BrowserTest.publishComponentReady(this);
        }
    },

    _search: function() {
        var terms = this._getSearchTerms();
        var store = this.grid.getStore();
        if (terms) {
            store.search = terms;
        } else {
            delete store.search;
        }
        store.loadPage(1);
    },

    _getSearchTerms: function() {
        var textBox = this.down('#searchTerms');
        return textBox && textBox.getValue();
    }
});
Ext.define('Rally.technicalservices.MessageBuilder',{

    constructor: function(config){
        Ext.apply(this,config);
    },

});
Ext.define('Rally.ui.tree.ProjectTree', {
    extend: 'Rally.ui.tree.Tree',
    alias: 'widget.rallyprojecttree',

    requires: [
        'Rally.ui.tree.PlainTreeItem'
    ],

    config: {
        topLevelModel: Ext.identityFn('Workspace'),

        topLevelStoreConfig: {
            fetch: ['Name', 'State', 'Workspace'],
            filters: [{
                property: 'State',
                value: 'Open'
            }, {
                property: 'Projects.State',
                value: 'Open'
            }],
            sorters: [{
                property: 'Name',
                direction: 'ASC'
            }],
            context: {
                workspace: 'null',
                project: undefined
            }
        },

        /**
         * @cfg {String}
         * If workspace _ref is supplied, we overwrite topLevelModel and topLevelStoreConfig
         * so that we only show projects under that workspace. We also do not show the top level workspace.
         */
        workspace: undefined,

        treeItemConfigForRecordFn: function(record){
            if(record.get('_type') === 'workspace'){
                return {
                    xtype: 'rallyplaintreeitem'
                };
            } else {
                return {
                    xtype: 'rallyplaintreeitem',
                    selectable: true
                };
            }
        },

        childModelTypeForRecordFn: function(){
            return 'Project';
        },

        givenAParentRecordWhatIsTheAttributeConnectingAChildToThisParentFn: function(record){
            return 'Parent';
        },

        childItemsStoreConfigForParentRecordFn: function(record){

            var storeConfig = {
                fetch: ['Name', 'Children:summary[State]', 'State', 'Workspace'],
                sorters: [{
                    property: 'Name',
                    direction: 'ASC'
                }]
            };

            if(record.get('_type') === 'workspace'){
                return Ext.apply(storeConfig, {
                    filters: [{
                        property: 'Parent',
                        value: 'null'
                    }],
                    context: {
                        workspace: record.get('_ref'),
                        project: null
                    }
                });
            } else {
                return Ext.apply(storeConfig, {
                    filters: [{
                        property: 'Parent',
                        value: record.get('_ref')
                    }],
                    context: {
                        workspace: record.get('Workspace')._ref,
                        project: null
                    }
                });
            }
        },

        canExpandFn: function(record){
            if(record.get('_type') === 'workspace'){
                //query filters out Workspaces with closed projects, so any workspace can be expanded
                return true;
            }
            return record.get('Summary').Children.State.Open;
        }
    },

    constructor: function(config) {
        if (config.workspace) {
            config.topLevelModel = 'Project';
            config.topLevelStoreConfig = {
                fetch: ['Name', 'State', 'Children:summary[State]'],
                filters: [{
                    property: 'State',
                    value: 'Open'
                }, {
                    property: 'Parent',
                    value: 'null'
                }],
                sorters: [{
                    property: 'Name',
                    direction: 'ASC'
                }],
                context: {
                    workspace: config.workspace,
                    project: undefined
                }
            };
        }

        this.callParent(arguments);
    }
});


Ext.define('CArABU.technicalservices.ArtifactCopier',{
    logger: new Rally.technicalservices.Logger(),
    mixins: {
        observable: 'Ext.util.Observable'
    },

    copyFields: null,


    constructor: function (config) {
        this.copyFields = config.copyFields;

        // The Observable constructor copies all of the properties of `config` on
        // to `this` using Ext.apply. Further, the `listeners` property is
        // processed to add listeners.
        //
        this.mixins.observable.constructor.call(this, config);

        this.addEvents(
            'copyerror',
            'copystatus',
            'copycomplete'
        );
    },
    copyRecords: function(records, destinationProject){
        this.logger.log('copyRecords', records, destinationProject);
        this.fireEvent('copystatus', Ext.String.format("Beginning copy of {0} artifacts.", records && records.length || 0));

        this.sourceRecords = records;
        this.destinationProject = destinationProject;
        this.copiedCount = 0;
        this.totalCount = records.length;

        Deft.Chain.sequence([
            this._fetchDestinationModels,
            this._copyStandaloneArtifacts,
            this._copyTasks,
            this._stitchArtifacts,
            this._updateSourceLinks
        ], this).then({
            success: function(){
                this.fireEvent('copycomplete');
            },
            failure: function(msg){
                this.fireEvent('copyerror',msg);
            },
            scope: this
        });
    },
    /**
     * _getModelNames:  creates a hash of the source workspace => destination workspace model names
     * and assigns them to a class level variable to be used by the _fetchDestinationModels function.
     * This uses a promise because we may need to retrieve the
     * portfolio item types for the destination
     * @param records
     * @private
     */
    _fetchDestinationModels: function(){
        var models = {},
            deferred = Ext.create('Deft.Deferred'),
            records = this.sourceRecords,
            destinationProject = this.destinationProject;

        Ext.Array.each(records, function(r){
            var type = r.get('_type').toLowerCase();
            if (!models[type]){
                models[type] = this._getDestinationModelType(type);
            }
        }, this);

        this.logger.log('_fetchDestinationModels',models, records);
        var context = {
                workspace: destinationProject.get('Workspace')._ref,
                project: destinationProject.get('_ref')
            },
            promises = _.map(models, function(val, key){
                return this._fetchModel(val, context);
            }, this);

        Deft.Promise.all(promises).then({
            success: function(results){
                console.log('success', results);
                var idx = 0;
                //This assumes that the results are returned in the order they are passed, which should
                //be a correct assumption
                Ext.Object.each(models, function(typeName, key){
                    models[key] = results[idx++];
                });
                this.modelHash = models;
                deferred.resolve();
            },
            failure: function(msg){
                console.log('failure', msg);
                deferred.reject(msg);
            },
            scope: this
        });

        return deferred;
    },
    _fetchModel: function(type, context){
        var deferred = Ext.create('Deft.Deferred');

        Rally.data.ModelFactory.getModel({
            type: type,
            context: context,
            success: function(model){
                deferred.resolve(model);
            },
            failure: function(){
                deferred.reject('Failed to getModel for ' + type);
            }
        });
        return deferred;
    },
    _copyStandaloneArtifacts: function(){
        this.logger.log('_copyStandaloneArtifacts', this.records);

        this.recordHash = {};
        var destProjectRef = this.destinationProject.get('_ref');;

        var promises = [],
            records = this.sourceRecords,
            deferred = Ext.create('Deft.Deferred'),
            sourceWorkspaceName = this.workspaceSettings.getCurrentContext().getWorkspace().Name,
            sourceProjectName = this.workspaceSettings.getCurrentContext().getProject().Name,
            linkField = this.workspaceSettings.getLinkField(this.destinationProject.get('Workspace').ObjectID);

        Ext.Array.each(records, function(r){
            if (r.get('_type').toLowerCase() !== 'task'){
                var overrides = {Project: destProjectRef};
                overrides[linkField] = this._getLinkValue(r, sourceWorkspaceName,sourceProjectName);
                promises.push(this.copyArtifact(r, overrides));
            }
        }, this);

        Deft.Promise.all(promises, this).then({
            success: function(){
                deferred.resolve();
            },
            failure: function(msg){
                deferred.reject(msg);
            },
            scope: this
        });
        return deferred;
    },
    _copyTasks: function(){
        var me = this,
            promises = [],
            deferred = Ext.create('Deft.Deferred'),
            destProjectRef = this.destinationProject.get('_ref'),
            sourceWorkspaceName = this.workspaceSettings.getCurrentContext().getWorkspace().Name,
            sourceProjectName = this.workspaceSettings.getCurrentContext().getProject().Name,
            linkField = this.workspaceSettings.getLinkField(this.destinationProject.get('Workspace').ObjectID);

        this.logger.log('_copyTasks', linkField);
        Ext.Array.each(this.sourceRecords, function(r){
            if (r.get('_type').toLowerCase() === 'task'){
                //find parent
                var parent = me._getTaskParentRef(r);
                if (parent){
                    me.logger.log('parentRef', parent);
                    var overrides = {Project: destProjectRef};
                    overrides["WorkProduct"] = parent;
                    overrides[linkField] = this._getLinkValue(r,sourceWorkspaceName,sourceProjectName);
                    promises.push(function(){ return me.copyArtifact(r, overrides); });
                }
            }
        }, this);

        Deft.Chain.sequence(promises, this).then({
            success: function(){
                deferred.resolve();
            },
            failure: function(msg){
                deferred.reject(msg);
            },
            scope: this
        });
        return deferred;
    },
    _stitchArtifacts: function(){
        var deferred = Ext.create('Deft.Deferred');

        //stitch non-tasks to parents:
        //userstory to userstory parent
        //userstory to portfolio item
        //portfolio item to portfolio item
        var updateRecords = [];

        this._populateDestinationParents(this.recordHash);

        Ext.Array.each(this.sourceRecords, function(r){
            var sourceID = r.get('ObjectID'),
                obj = this.recordHash[sourceID];
            console.log('source',sourceID,obj, obj.destinationRecord, obj.destinationParent);
            if (obj && obj.destinationParent && obj.destinationRecord){
                 obj.destinationRecord.set(obj.destinationParentField, obj.destinationParent );
                updateRecords.push(obj.destinationRecord);
            }
        }, this);

        this.logger.log('_stitchArtifacts', updateRecords);
        if (updateRecords && updateRecords.length > 0){
            var bulkUpdateStore = Ext.create('Rally.data.wsapi.batch.Store', {
                data: updateRecords
            });

            bulkUpdateStore.sync({
                success: function(batch) {
                    console.log('bulkUpdateStore success', batch);
                    deferred.resolve();
                },
                failure: function(batch){
                    console.log('bulkUpdateStore failure', batch);
                    deferred.reject();
                }
            });
        } else {
            deferred.resolve();
        }

        return deferred;
    },
    _updateSourceLinks: function(){
        var sourceLinkField = this.workspaceSettings.getCurrentWorkspace().linkField,
            deferred = Ext.create('Deft.Deferred'),
            workspaceName = this.destinationProject.get('Workspace')._refObjectName,
            projectName = this.destinationProject.get('Name'),
            updates = [];

        Ext.Object.each(this.recordHash, function(key, obj){
            var sourceLinkValue = this._getLinkValue(obj.destinationRecord,workspaceName,projectName);
            obj.sourceRecord.set(sourceLinkField, sourceLinkValue);
            updates.push(obj.sourceRecord);
        }, this);

        this.logger.log('_updateSourceLinks', updates);
        var bulkUpdateStore = Ext.create('Rally.data.wsapi.batch.Store', {
            data: updates
        });

        bulkUpdateStore.sync({
            success: function(batch) {
                console.log('bulkUpdateStore success', batch);
                deferred.resolve();
            },
            failure: function(batch){
                console.log('bulkUpdateStore failure', batch);
                deferred.reject();
            }
        });
        return deferred;

    },
    _populateDestinationParents: function(recordHash){
        //TODO, if we wanted to search the destination for a parent (assuming it was copied at an earlier date), this will allow us to do that and link up.
        Ext.Object.each(recordHash, function(key, obj){
            if (obj.sourceRecord.get('_type') !== 'task'){
                var parent = obj.sourceRecord.get('Parent') || obj.sourceRecord.get('PortfolioItem') || null;
                if (parent && parent.ObjectID && recordHash[parent.ObjectID] && recordHash[parent.ObjectID].destinationRecord){
                    var parentDestinationRecord = recordHash[parent.ObjectID].destinationRecord;
                    obj.destinationParent = Ext.String.format("/{0}/{1}", parentDestinationRecord.get('_type'), parentDestinationRecord.get('ObjectID'));
                    obj.destinationParentField = this._getParentField(obj.destinationRecord, recordHash[parent.ObjectID].destinationRecord);
                }
            }
        }, this);
        this.logger.log('_populateDestinationParent', recordHash);
    },
    _getParentField: function(child, parent){
        var childType = child.get('_type'),
            parentType = parent.get('_type');

        if (this._isPortfolioItem(parentType) && !this._isPortfolioItem(childType)){
            return "PortfolioItem";
        }
        return "Parent";

    },
    _isPortfolioItem: function(type){
        return /portfolioitem/.test(type.toLowerCase());
    },
    //_restoreStates: function(){
    //    var deferred = Ext.create('Deft.Deferred');
    //    //TODO:  I'm not sure this is going to be a problem...
    //    deferred.resolve();
    //
    //    return deferred;
    //},
    _getTaskParentRef: function(sourceTaskObject){

        var sourceParent = sourceTaskObject.get('WorkProduct').ObjectID;
        if (this.recordHash[sourceParent] && this.recordHash[sourceParent].destinationRecord){
            return this.recordHash[sourceParent].destinationRecord.get('ObjectID');
        }
        return null;
    },
    _getModel: function(type){
        return this.modelHash[type.toLowerCase()] || null;
    },
    _getDestinationModelType: function(sourceType){

        if (this._isPortfolioItem(sourceType)) {
            //TODO get the mapped portfolio itme type
            return sourceType;
        }
        return sourceType;

    },
    copyArtifact: function(record, overrides){
        var deferred = Ext.create('Deft.Deferred'),
            sourceOid = record.get('ObjectID');
        this.logger.log('copyArtifact', record.get('FormattedID'));

        this.recordHash[sourceOid] = {
            sourceRecord: record,
            sourceParent: null,
            destinationRecord: null,
            destinationParent: null,
            error: null
        };

        var model = this._getModel(record.get('_type'));
        if (!model){
            //Todo handle error
        }

        this.copiedCount++;
        this.fireEvent('copystatus', Ext.String.format("Copying {0} of {1} artifacts.", this.copiedCount, this.totalCount));

        var fields = this._getFieldsToCopy(record, overrides);

        Ext.create(model, fields).save({
            callback: function(result, operation){
                this.logger.log('copyArtifact callback',record.get('FormattedID'), operation.wasSuccessful(), result, operation);
                if (operation.wasSuccessful()){
                    this.recordHash[sourceOid].destinationRecord = result;
                    deferred.resolve();
                } else {
                    this.recordHash[sourceOid].destinationRecord = result;
                    this.recordHash[sourceOid].error = operation.error.errors.join(',');
                    deferred.reject(operation.error.errors.join(','));
                }
            },
            scope: this
        });
        return deferred;
    },
    _getFieldsToCopy: function(record, overrides){
        var sourceFields = record.getFields(),
            sourceType = record.get('_type'),
            copyableFields = _.filter(sourceFields, this._fieldIsCopyable, this),
            fieldHash = {};

        this.logger.log('getFieldsToCopy',copyableFields);

        Ext.Array.each(copyableFields, function(f){

            //If there is a mapping, we need to get the mapped value
            var val = record.get(f.name) || null;

            if (Ext.isObject(val)){
                val = val._refObjectName;
            }

            var mappedVal = this._getMappedValue(val, f.name,  sourceType);

            this.logger.log('field', f.name, f.attributeDefinition.AttributeType, val,record.get(f.name), mappedVal);

            if (mappedVal){
                fieldHash[f.name] = mappedVal;
            }
        }, this);

        Ext.Object.each(overrides, function(key, val){
            fieldHash[key] = val;
        });
        this.logger.log('fieldHash', fieldHash);
        return fieldHash;
    },
    _getMappedValue: function(sourceValue, fieldName, sourceType){
        var destWorkspaceRef = this.destinationProject.get('Workspace')._ref,
        valueMap = this.workspaceSettings.getValueMap(destWorkspaceRef, sourceType, fieldName);
        this.logger.log('_getMappedValue', sourceValue, valueMap, destWorkspaceRef, sourceType, fieldName);
        if (!valueMap){
            return sourceValue;
        }

        if (sourceValue){
            return valueMap[sourceValue] || null;
        }
        return null;
    },
    _fieldIsCopyable: function(field){

        if (Ext.Array.contains(this.copyFields, field.name)){
            return true;
        }
        return false;
    },
    _getLinkValue: function(artifact, workspaceName, projectName){
        var link_text = Ext.String.format('[{0}][{1}] {2}',workspaceName, projectName, artifact.get('FormattedID'));

        return Rally.nav.DetailLink.getLink({
            record: artifact,
            text: link_text
        });
    }

});

Ext.define('CArABU.technicalservices.ArtifactLoader',{
    logger: new Rally.technicalservices.Logger(),
    mixins: {
        observable: 'Ext.util.Observable'
    },

  //  fetchFields: ['Name','ObjectID','ScheduleState','State','Description','FormattedID','PlannedStartDate','PlannedEndDate'],
    portfolioItemTypes: [],


    constructor: function (config) {
        // The Observable constructor copies all of the properties of `config` on
        // to `this` using Ext.apply. Further, the `listeners` property is
        // processed to add listeners.
        //
        this.loadLinkedItems = config.loadLinkedItems || false;
        this.fetchFields = config.copyFields;

        this.logger.log('ArtifactLoader Constructor', config, this.fetchFields);
        this.mixins.observable.constructor.call(this, config);

        this.addEvents(
            'loaderror',
            'loadcomplete'
        );
    },
    loadHierarchy: function(records){
        var oids = _.map(records, function(r){ return r.get('ObjectID'); }),
            types = this._getArtifactModelTypes(),
            find = {
                "__At": "current",
                "_ItemHierarchy": {$in: oids},
                "_TypeHierarchy": {$in: types}
                //TODO, do we want to restrict projects?
            };

        if (this.loadLinkedItems){
            var linkedField = this.workspaceSettings.getLinkField();
            find[linkedField] = {$ne: null}
        }

        this.logger.log('loadHierarchy', records, oids, types);
        var lbStore = Ext.create('Rally.data.lookback.SnapshotStore',{
            fetch: ['ObjectID'],
            find: find,
            limit: 'Infinity',
            removeUnauthorizedSnapshots: true
        });

        lbStore.load({
            callback: function(hierarchyRecords, operation, success){
                this.logger.log('loadHierarchy', hierarchyRecords, operation, success);
                if (success){
                    var hierarchyOids = _.map(hierarchyRecords, function(r){ return r.get('ObjectID'); });
                    if (!hierarchyOids || hierarchyOids.length === 0){
                        this.fireEvent('loaderror', "No records found.");
                    }
                    this._fetchArtifacts(hierarchyOids).then({
                        success: function(artifacts){
                            this.fireEvent('loadcomplete', artifacts);
                        },
                        failure: function(operation){
                            var errMsg = "Error loading records for hierarchy: " + operation.error.errors.join(',');
                            this.fireEvent('loaderror', errMsg);
                        },
                        scope: this
                    });
                } else {
                    var errMsg = "Error loading hierarchy: " + operation.error.errors.join(',');
                    this.fireEvent('loaderror', errMsg);
                }
            },
            scope: this
        });
    },
    load: function(records){
        this.fireEvent('loadcomplete', records);
    },
    _fetchArtifacts: function(objectIDs){
        var deferred = Ext.create('Deft.Deferred'),
            chunks = this._getChunks(objectIDs),
            promises = [];

        Ext.Array.each(chunks, function(chunkArray){
            promises.push(this._fetchArtifactsChunk(chunkArray));
        }, this);

        Deft.Promise.all(promises).then({
            success: function(results){
               deferred.resolve(_.flatten(results));
            },
            failure: function(operation){
                deferred.reject(operation);
            }
        });
        return deferred.promise;

    },
    _getChunks: function(objectIDs){
        var chunks = [],
            maxListSize = 25,
            idx = 0;

        chunks[idx] = [];
        _.each(objectIDs, function(oid){
            if (chunks[idx].length >= maxListSize){
                idx++;
                chunks[idx] = [];
            }
            chunks[idx].push(oid);
        });

        return chunks;
    },
    _fetchArtifactsChunk: function(objectIDs, options){
        var deferred = Ext.create('Deft.Deferred'),
            filters = _.map(objectIDs, function(o){
            return {
                property: 'ObjectID',
                value: o
            }
        });
        filters = Rally.data.wsapi.Filter.or(filters);

        this.logger.log('_fetchArtifactsChunk', objectIDs, filters && filters.toString(),this._getArtifactFetchList(), this._getArtifactModelTypes());
       Ext.create('Rally.data.wsapi.artifact.Store',{
            models: this._getArtifactModelTypes(),
            fetch: this._getArtifactFetchList(),
            filters: filters
        }).load({
            callback: function(records, operation){
                if (operation.wasSuccessful()){
                    deferred.resolve(records);
                } else {
                    deferred.reject(operation);
                }
            }
        });
        return deferred;
    },
    _getArtifactModelTypes: function(){
        return this.portfolioItemTypes.concat(['HierarchicalRequirement','Task']);
    },
    _getArtifactFetchList: function(){
        return this.fetchFields.concat(['Parent','WorkProduct','PortfolioItem','ObjectID']);
    }
});

Ext.define('CArABU.technicalservices.ArtifactSyncer',{
    logger: new Rally.technicalservices.Logger(),
    mixins: {
        observable: 'Ext.util.Observable'
    },

    fieldsToSync: {
        hierarchicalrequirement: [],
        task: [],
        portfolioitem: []
    },
    constructor: function(config){
        this.workspaceSettings = config.workspaceSettings;
        this.fetchFields = config.copyFields;
        this.context = config.context;

        this.mixins.observable.constructor.call(this, config);

        this.addEvents(
            'syncerror',
            'syncstatus',
            'synccomplete'
        );
    },
    sync: function(sourceRecords){
        var linkField = this.workspaceSettings.getLinkField();
        this.syncedRecords = [];
        this.unsyncedRecords = [];

        Ext.Array.each(sourceRecords, function(r){
            this.syncLinkedArtifact(r, linkField);
        }, this);

    },
    syncLinkedArtifact: function(sourceRecord, linkField){
        var link = sourceRecord.get(linkField),
            matches = /<a.*href=".*\/#\/(\d+).*\/detail\/.*\/(\d+)">(.*)<\/a>/.exec(link),
            objectID = null,
            projectOid = null,
            store_context = null,
            friendly_text = null,
            ref = null;

        if (!matches){
            this.logger.log('No matches for artifact ' + sourceRecord.get('FormattedID') ,link, matches);
            this.unsyncedRecords.push(sourceRecord);
            return;
        }

        if (matches){
            objectID = matches[2] || null;
            projectOid =matches[1] || null;
            store_context = this._getLinkedContext(projectOid);
            friendly_text = matches[3] || 'Unknown';
        }

        if (store_context.workspace == null || store_context.project==null){
            this.logger.log('Context not found for ' + sourceRecord.get('FormattedID'), projectOid, store_context);
            this.unsyncedRecords.push(sourceRecord);
            return;
        }
        var modelName = this._getDestinationModelType(sourceRecord.get('_type'), store_context);
        console.log('_getLinkedArtifactInfo', objectID,store_context, modelName);
        Rally.data.ModelFactory.getModel({
            type: modelName,
            context: store_context,
            success: function(model){
                model.load(objectID, {
                    fetch: this.fetchFields,
                    callback: function(destinationRecord, operation) {
                        if(operation.wasSuccessful()) {
                            this._syncRecord(sourceRecord, destinationRecord);
                            this.logger.log('Success', destinationRecord.get('LastUpdateDate'), sourceRecord.get('LastUpdateDate'));
                        } else {
                            this.unsyncedRecords.push(sourceRecord);
                            this.logger.log('FAILURE', operation);
                        }
                    },
                    scope: this
                });
            },
            failure: function(){
                this.unsyncedRecords.push(sourceRecord);
                this.logger.log('FAILURE to load Model ' + modelName);
            },
            scope: this
        });

    },
    _syncRecord: function(sourceRecord, destinationRecord){
        var type = sourceRecord.get('_type');
        this.logger.log('_syncRecord', sourceRecord, destinationRecord.get('LastUpdateDate'), sourceRecord.get('LastUpdateDate'), type);

        var syncSource = sourceRecord,
            syncTarget = destinationRecord;

        if (sourceRecord.get('LastUpdateDate') < destinationRecord.get('LastUpdateDate')){
            syncSource = destinationRecord;
            syncTarget= sourceRecord;
        }

        Ext.Array.each(this.workspaceSettings.getSyncFields(type), function(f){
            var val = syncSource.get(f);
            val = this.workspaceSettings.getMappedValue(f,syncSource, syncTarget);
            syncTarget.set(f,val);
        }, this);
        syncTarget.save({
            callback: function(record, operation){
                this.logger.log('syncTarget saved', record);
                this.syncedRecords.push(sourceRecord);
            },
            scope:this
        });


    },
    _getDestinationModelType: function(sourceType, destinationContext){

        if (this._isPortfolioItem(sourceType)) {
            //TODO get the mapped portfolio itme type
            return sourceType;
        }
        return sourceType;

    },
    _isPortfolioItem: function(type){
        return /portfolioitem/.test(type.toLowerCase());
    },
    _getLinkedContext: function(projectOid){
        var workspace = this.workspaceSettings.getWorkspaceForProject(projectOid);
        return {workspace: '/workspace/' + workspace, project: '/project/' + Number(projectOid)};
    },
    _updateArtifact: function(artifact_to_be_updated, source_artifact) {

        _.each(this.fieldsToCopy, function (f) {
            artifact_to_be_updated.set(f, this._getFieldValue(source_artifact, f));
        }, this);

        this.logger.log('_updateArtifact (dirty)', artifact_to_be_updated, source_artifact, this.fieldsToCopy);
        artifact_to_be_updated.save({
            scope: this,
            callback: function (record, operation) {
                this.logger.log('_updateArtifact callback returned',record, operation);
                if (operation.wasSuccessful()) {
                    this.fireEvent('artifactupdated', record);
                } else {
                    this.fireEvent('updateerror', this.buildErrorMessage(Ext.String.format('Error updating artifact {0}', artifact_to_be_updated.get('FormattedID')), operation));
                }
            }
        });
    }

});
Ext.define('Rally.technicalservices.ArtifactTree',{
    logger: new Rally.technicalservices.Logger(),
    mixins: {
        observable: 'Ext.util.Observable'
    },

    rootArtifact: undefined,
    modelHash: null,
    portfolioItemTypes: undefined,
    childTypesBlacklist: undefined,
    parentChildTypeMap: null,
    blacklistFields: null,

    stoppedByError: false,

    constructor: function(config){

        this.childTypesBlacklist = config.childTypesBlacklist || ['testcase','defectsuite','defect'];
        this.parentChildTypeMap = this._setupParentChildMap(config.portfolioItemTypes);
        this.modelHash = {};

        this.mixins.observable.constructor.call(this, config);

    },
    load: function(rootArtifact, rootParent){
        this.totalRecords = 1;
        this.tree = {};
        this.stoppedByError = false;
        this.rootArtifact = rootArtifact;



        //this._loadModel(rootArtifact);

    },
    _updateStatus: function(){
        this.fireEvent('statusupdate', this.completedArtifacts, this.totalArtifacts);
    },
    deepCopy: function(){
        this.logger.log('deepCopy');
        var me = this;
        this.totalArtifacts = _.keys(this.tree).length || 0;
        this.completedArtifacts = 0;

        this.fireEvent('statusupdate', 0, this.totalArtifacts);
        var overrides = {PortfolioItem: "", Parent: ""};

        this.logger.log('deepCopy.overrides',overrides);
        me._copyStandaloneArtifacts(overrides).then({
            success: function(){
                this.logger.log('deepCopy. _copyStandaloneArtifacts success');
                Deft.Chain.sequence([
                    me._copyTasks,
                    me._updateCollections,
                    me._stitchArtifacts
                ],me).then({
                    success: function(){
                       me.fireEvent('copycompleted', me.tree[me.rootArtifact.get('ObjectID')].copyRecord);

                    },
                    failure: function(msg){
                        me._deleteArtifacts();
                        me.fireEvent('copyerror',msg);
                    },
                    scope: me
                });
            },
            failure: function(msg){
                this.logger.log('deepCopy. _copyStandaloneArtifacts failure', msg);
            },
            scope: this
        });
    },
    _deleteArtifacts: function(){
        this.logger.log('_deleteArtifacts');
        var tasks = [],
            artifacts = [];

        _.each(this.tree, function(artifact, oid) {
            //first we need to delete tasks
            if (artifact.copyRecord) {
                if (artifact.copyRecord.get('_type').toLowerCase() === 'task') {
                    tasks.push(artifact);
                } else {
                    artifacts.push(artifact);
                }
            }
        });

        var promises = [];
        _.each(tasks, function(t){
            promises.push(function(){ return this._deleteArtifact(t)});
        }, this);
        _.each(artifacts, function(a){
            promises.push(function(){ return this._deleteArtifact(a)});
        }, this);


        Deft.Chain.sequence(promises, this).then({
            success: function(){
                this.logger.log('artifacts deleted');
            },
            scope: this
        });
    },
    _deleteArtifact: function(artifact){
        var deferred = Ext.create('Deft.Deferred');

        artifact.deleted = false;
        if (artifact.copyRecord){
            var fid = artifact.copyRecord.get('FormattedID');
            artifact.copyRecord.destroy({
                callback: function(result, operation){
                    this.logger.log('artifact deleted',fid, operation.wasSuccessful(), result, operation);
                    if (operation.wasSuccessful()){
                        artifact.copyRecord = null;
                        artifact.deleted = true;
                    }
                    deferred.resolve();
                },
                scope: this
            });
        }
        return deferred;
    },
    _copyStandaloneArtifacts: function(overrides){
        this.logger.log('_copyStandaloneArtifacts', overrides);
        var promises = [],
            deferred = Ext.create('Deft.Deferred');

        _.each(this.tree, function(obj, oid){
            if (obj.record.get('_type').toLowerCase() !== 'task' && !obj.copyRecord){
                promises.push(this.copyArtifact(oid, overrides));
            }
        }, this);

        Deft.Promise.all(promises, this).then({
            success: function(){
                deferred.resolve();
            },
            failure: function(msg){
                deferred.reject(msg);
            },
            scope: this
        });
        return deferred;
    },
    _stitchArtifacts: function(){
        this.logger.log('_stitchArtifacts');

        var promises = [],
            deferred = Ext.create('Deft.Deferred');

        _.each(this.tree, function(obj, oid){

            var childTypes = this.parentChildTypeMap[obj.record.get('_type').toLowerCase()] || [],
                newParentRef = obj.copyRecord && obj.copyRecord.get('_ref');

            _.each(childTypes, function(ct){
                var children = obj[ct.collectionName] || [];
                if (children.length > 0){
                    _.each(children, function(childOid){
                        if (this.tree[childOid].copyRecord){
                            this.tree[childOid].copyRecord.set(ct.parentField, newParentRef);
                            promises.push(function(){ return this.tree[childOid].copyRecord.save(); });
                        }
                    }, this);
                }
            },this);
        }, this);

        this.logger.log('_stitchArtifacts', promises.length);

        Deft.Chain.sequence(promises, this).then({
            success: function(){
                this.logger.log('_stitchArtifacts success');
                deferred.resolve();
            },
            failure: function(msg){
                this.logger.log('_stitchArtifacts failed', msg);
                deferred.reject(msg);
            },
            scope: this
        });

        return deferred;
    },
    _getNewRefs: function(oldOids, collectionField){
        var newRefs = [];
        if (collectionField === 'Predecessors'){
            _.each(oldOids, function(oid){
                if (this.tree[oid] && this.tree[oid].copyRecord){
                    newRefs.push(this.tree[oid].copyRecord.get('_ref'));
                }
            }, this);
        }
        return newRefs;
    },
    _updateCollections: function(){
        var promises = [],
            deferred = Ext.create('Deft.Deferred'),
            collectionFields = ['Predecessors','Tags'];

        _.each(this.tree, function(obj, oid) {
            _.each(collectionFields, function (cf) {
                console.log('_updateCollections', obj.record.get('_type'), cf, obj[cf]);
                if (obj[cf] && obj[cf].length > 0) {
                    if (cf === 'Predecessors') {
                        promises.push(function () {
                            var newRefs = this._getNewRefs(obj[cf], cf)
                            return this._updateCollection(obj.copyRecord, cf, newRefs);
                        });

                    } else if (cf === 'Tags') {

                        promises.push(function () {
                            var newRefs = obj[cf];
                            return this._updateCollection(obj.copyRecord, cf, newRefs);
                        });
                    }
                }
            }, this);
        });

        Deft.Chain.sequence(promises, this).then({
            success: function(){
                this.logger.log('_updateCollections success');
                deferred.resolve();
            },
            failure: function(msg){
                this.logger.log('_updateCollections failed', msg);
                deferred.reject(msg);
            },
            scope: this
        });

        return deferred;
    },
    _updateCollection: function(newArtifact, collectionName, collectionRefs){
        this.logger.log('_updateCollection', newArtifact, collectionName, collectionRefs);

        var deferred = Ext.create('Deft.Deferred'),
            store = newArtifact.getCollection(collectionName);

        store.load({
            callback: function(){
                Ext.Array.each(collectionRefs, function(cr){
                    store.add(cr)
                });
                store.sync({
                    callback: function(){
                        deferred.resolve();
                    }
                });
            }
        });
        return deferred;
    },

    _updateArtifact: function(rec){
        var deferred = Ext.create('Deft.Deferred');
        this.logger.log('updateArtifact');
        rec.save({
            callback: function(result, operation){
                if(operation.wasSuccessful()) {
                    deferred.resolve();
                } else {
                    deferred.reject("Update for " + rec.get('FormattedID') + " failed: " + operation.error.errors.join(','));
                }
            }
        });
        return deferred;
    },
    _copyTasks: function(){
        this.logger.log('_copyTasks');
        var me = this,
            promises = [],
            deferred = Ext.create('Deft.Deferred');

        _.each(this.tree, function(obj, oid){
            if (obj.record.get('_type').toLowerCase() === 'task'){
                //find parent
                var parent = me._getTaskParentRef(oid);
                if (parent){
                    me.logger.log('parentRef', parent);
                    promises.push(function(){ return me.copyArtifact(oid, {WorkProduct: parent}); });
                }
            }
        }, this);

        Deft.Chain.sequence(promises, this).then({
            success: function(){
                deferred.resolve();
            },
            failure: function(msg){
                deferred.reject(msg);
            },
            scope: this
        });
        return deferred;
    },
    _getTaskParentRef: function(taskOid){
        var parentOid = null;

        _.each(this.tree, function(obj, oid){
            var tasks = obj && obj.Tasks || [];
            console.log(tasks, taskOid,Ext.Array.contains(tasks, Number(taskOid)));
            if (Ext.Array.contains(tasks, Number(taskOid))){
                parentOid = obj.copyRecord && obj.copyRecord.get('ObjectID') || null;
                return false;
            }
        });
        return parentOid;
    },
    copyArtifact: function(artifactOid, overrides){
        var deferred = Ext.create('Deft.Deferred'),
            artifact = this.tree[artifactOid].record;
        this.logger.log('copyArtifact', artifact.get('FormattedID'));

        this._fetchModel(artifact.get('_type')).then({
            success: function(model){
                var fields = this.getFieldsToCopy(artifact,overrides);

                Ext.create(model, fields).save({
                    callback: function(result, operation){
                        this.logger.log('copyArtifact callback',artifact.get('FormattedID'), operation.wasSuccessful(), result, operation);
                        if (operation.wasSuccessful()){
                            this.tree[artifactOid].copyRecord = result;
                            this.completedArtifacts++;
                            this._updateStatus();
                            deferred.resolve();
                        } else {
                            this.tree[artifactOid].copyRecord = null;
                            this.tree[artifactOid].error = operation.error.errors.join(',');
                            deferred.reject(operation.error.errors.join(','));
                        }
                    },
                    scope: this
                });
            },
            failure: function(msg){
                deferred.reject(msg);
            },
            scope: this
        });
        return deferred;
    },
    getFieldsToCopy: function(artifactToCopy, overrideFields){
        var fields = artifactToCopy.getFields(),
            copyableFields = _.filter(fields, this._fieldIsCopyable, this),
            fieldHash = {};

        this.logger.log('getFieldsToCopy',copyableFields);

        _.each(copyableFields, function(f){

            //if field is collection and count === 0, then it can be null, otherwise, we need to copy the cooleciton
            if (f.attributeDefinition.AttributeType !== "COLLECTION"){
                var val = artifactToCopy.get(f.name) || null;

                if (val && Ext.isObject(val)){  //If this is a reference field, then we need to use the ObjectId
                    val = val._ref;
                }

                if (_.has(overrideFields, f.name)){
                    val = overrideFields[f.name];
                }
                this.logger.log('field', f.name, f.attributeDefinition.AttributeType, val,artifactToCopy.get(f.name));
                if (val){
                    fieldHash[f.name] = val;
                }
            }
        }, this);

        return fieldHash;
    },
    _fieldIsCopyable: function(field){

        if (Ext.Array.contains(this.blacklistFields, field.name)){

            return false;
        }
        if (field.hidden || field.readOnly){

            return false;
        }
        if (field.attributeDefinition){

            return true;
        }
        return false;
    },


    _loadModel: function(artifact){
        this._fetchModel(artifact.get('_type')).then({
            success: function(model) {
                this.logger.log('_loadModel success');
                this._loadArtifact(model, artifact);
            },
            failure: function(msg){
                this.tree[artifact.get('ObjectID')].error = msg;
                this._checkForDoneness(msg);

            },
            scope: this
        });

    },
    _loadArtifact: function(model, artifact){
        this.logger.log('_loadArtifact', artifact);
        if (this.stoppedByError){
            return;
        }

        var oid = artifact.get('ObjectID');
        model.load(oid, {
            fetch: true,
            scope: this,
            callback: function(loadedArtifact, operation) {
                if(operation.wasSuccessful()) {
                    this.logger.log('_loadArtifact success', oid, loadedArtifact);
                    this.tree[oid] = this.getTreeNode(loadedArtifact);
                    this._loadArtifactCollections(loadedArtifact);
                    //this._loadArtifactChildren(loadedArtifact);
                } else {
                    this.logger.log('_loadArtifact failure', oid, operation);
                    var msg = Ext.String.format("Failed to load {0}/{1} with error: {2} ",artifact.get('_type'),artifact.get('ObjectID'),operation.error.errors.join(','));
                    this.tree[oid].error = msg;
                    this._checkForDoneness(msg);
                }
            }
        });
    },
    getTreeNode: function(artifact){
        return {record: artifact, error: null, childCount: {}};
    },
    _loadArtifactCollections: function(artifact){
        var collectionFields = ['Predecessors','Tags'],
            promises = [];

        _.each(collectionFields, function(cf){
            if (artifact.get(cf) && artifact.get(cf).Count && artifact.get(cf).Count > 0){
                promises.push(this._loadCollection(artifact, cf, false, cf === 'Tags'));
            }
        }, this);

        if (promises.length > 0){
            Deft.Promise.all(promises).then({
                success: function(){
                    this.logger.log('artifact collections loaded', artifact);
                    this._loadArtifactChildren(artifact)
                },
                failure: function(){},
                scope: this
            });
        } else {
            this._loadArtifactChildren(artifact);
        }
    },
    _loadArtifactChildren: function(artifact){
        if (this.stoppedByError){
            return;
        }

        var childrenToLoad = this.parentChildTypeMap[artifact.get('_type').toLowerCase()],
            collectionsLoading = 0;

        childrenToLoad = _.filter(childrenToLoad, function(c){
            if (!Ext.Array.contains(this.childTypesBlacklist, c.typePath)){
                return true;
            }
        }, this);

        this.logger.log('_loadArtifactChildren',childrenToLoad, this.parentChildTypeMap, artifact.get('_type').toLowerCase());
        _.each(childrenToLoad, function(c){
            this.logger.log('_loadArtifactChildren child',c, artifact.get(c.collectionName).Count);
            if (artifact.get(c.collectionName).Count > 0){
                this.totalRecords = this.totalRecords + artifact.get(c.collectionName).Count;
                this._loadCollection(artifact, c.collectionName, true);
            }
        }, this);

        if (collectionsLoading === 0){
            this._checkForDoneness();
        }
    },
    _checkForDoneness: function(errorMessage){
        this.logger.log('_checkForDoneness', this.tree, this.totalRecords, _.keys(this.tree).length, errorMessage);
        if (errorMessage){
            this.stoppedByError = true;
            this.fireEvent('error', errorMessage);
            return;
        }
        if (this.tree && _.keys(this.tree).length === this.totalRecords){
            this.logger.log('TREE LOADED!')
            this.fireEvent('treeloaded', this);
        }
    },
    _loadCollection: function(artifact, collectionName, loadRecord, preserveRefs){
        var deferred = Ext.create('Deft.Deferred'),
            parentOid = artifact.get('ObjectID');

        this.tree[parentOid][collectionName] = [];

        artifact.getCollection(collectionName).load({
            fetch: ['ObjectID'],
            callback: function(records, operation, success) {
                this.logger.log('_loadCollection callback', collectionName, records, success);

                if (success){
                    _.each(records, function(r){
                        var val = r.get('ObjectID');
                        if (preserveRefs){
                            val = r.get('_ref');
                        }
                        this.tree[parentOid][collectionName].push(val);
                        if (loadRecord){
                            this._loadModel(r);
                        }
                    }, this);
                    deferred.resolve();
                } else {
                    var msg = Ext.String.format("Failed to load collecton for {0}/{1} with error: {2} ",artifact.get('_type'),artifact.get('ObjectID'),operation.error.errors.join(','));
                    this.tree[parentOid].error = msg;
                    this._checkForDoneness(msg);
                    deferred.reject(msg);
                }
            },
            scope: this
        });

        return deferred;
    },
    _fetchModel: function(type){
        var deferred = Ext.create('Deft.Deferred');
        if (this.modelHash[type]){
            deferred.resolve(this.modelHash[type]);
        } else {
            Rally.data.ModelFactory.getModel({
                type: type,
                success: function(model){
                    this.modelHash[type] = model;
                    deferred.resolve(model);
                },
                failure: function(){
                    var msg = 'Failed to load model: ' + type;
                    this._checkForDoneness(msg);
                    deferred.reject(msg);
                },
                scope: this
            });
        }
        return deferred;
    },
    _setupParentChildMap: function(portfolioItemsByOrdinal){
        var parentChildTypeMap = {
            hierarchicalrequirement: [
                {typePath: 'defect', collectionName: 'Defects', parentField: 'Requirement'},
                {typePath: 'task', collectionName: 'Tasks', parentField: 'WorkProduct'},
                {typePath: 'testcase', collectionName: 'TestCases', parentField: 'WorkProduct'},
                {typePath: 'hierarchicalrequirement', collectionName: 'Children', parentField: 'Parent'}
            ],
            defect: [
                {typePath: 'task', collectionName: 'Tasks', parentField: 'WorkProduct'},
                {typePath: 'testcase', collectionName: 'TestCases', parentField: 'WorkProduct'}
            ],
            defectsuite: [
                {typePath: 'defect', collectionName: 'Defects', parentField: 'DefectSuites'},
                {typePath: 'task', collectionName: 'Tasks', parentField: 'WorkProduct'},
                {typePath: 'testcase', collectionName: 'TestCases', parentField: 'WorkProduct'}
            ],
            testset: [
                {typePath: 'task', collectionName: 'Tasks', parentField: 'WorkProduct'},
                {typePath: 'testcase', collectionName: 'TestCases', parentField: 'TestSets'}
            ]
        };

        if (portfolioItemsByOrdinal && portfolioItemsByOrdinal.length > 0){
            parentChildTypeMap[portfolioItemsByOrdinal[0].toLowerCase()] = [{typePath: 'hierarchicalrequirement', collectionName: 'UserStories', parentField: 'PortfolioItem'}];

            for (var i = 1; i<portfolioItemsByOrdinal.length ; i++){
                parentChildTypeMap[portfolioItemsByOrdinal[i].toLowerCase()] = [{typePath: portfolioItemsByOrdinal[i-1], collectionName: 'Children', parentField: 'Parent'}];
            }
        }
        return parentChildTypeMap;
    },
    _fetchGrandparent: function(parentObj){
        var deferred = Ext.create('Deft.Deferred');

        Ext.create('Rally.data.wsapi.Store',{
            model: parentObj._type,
            fetch: ['Parent','FormattedID'],
            filters: [{
                property: 'FormattedID',
                value: parentObj.FormattedID
            }]
        }).load({
            callback: function(records, operation){
                if (operation.wasSuccessful()){
                    deferred.resolve(records[0] && records[0].get('Parent') && records[0].get('Parent').FormattedID);
                } else {
                    deferred.reject('Error loading parent record: ' + operation.error.errors.join(','));
                }
            }
        });

        return deferred;
    }
});

Ext.define('CA.technicalservices.BulkMenuItem.xWorkspaceCopyBase', {
    alias: 'widget.bulkmenuitemxworkspacecopybase',
    extend: 'Rally.ui.menu.bulk.MenuItem',

    config: {

        handler: function () {
            this._showOptions();
        }
    },
    _showOptions: function() {

        var dlg = Ext.create('CA.technicalservices.xWorkspaceCopyDialog',{
            title: "Select Destination Project",
            workspaceSettings: this.workspaceSettings,
            context: this.context
        });
        dlg.on('optionschosen', this._doAction, this);
        dlg.show();
    },
    _doAction: function(options){

        this._loadRecordsToCopy().then({
            success: function(records){
                this.totalCount = records.length;
                this._copyRecords(records, options);
            },
            failure: function(errMsg){
                this.onSuccess([],this.records,[errMsg]);
            },
            scope: this
        });
    },
    _copyRecords: function(records, options){
        console.log('options', options)
        var copier = Ext.create('CArABU.technicalservices.ArtifactCopier',{
            workspaceSettings: this.workspaceSettings,
            copyFields: this.copyFields,
            context: this.context,
            listeners: {
                copyerror: function(msg){
                    console.log('copyerror', msg);
                    Rally.ui.notify.Notifier.showError({message: msg});
                },
                copystatus: function(msg){
                    Rally.ui.notify.Notifier.show({message: msg});
                    console.log('copystatus',msg);
                },
                copycomplete: function(){
                    this.onSuccess(records, [], []);
                },
                scope: this
            }
        });
        copier.copyRecords(records, options.project);
    },
    onSuccess: function (successfulRecords, unsuccessfulRecords, errorMessages) {

        var message = successfulRecords.length + (successfulRecords.length === 1 ? ' item has ' : ' items have ');
        if(successfulRecords.length === this.totalCount) {
            Rally.ui.notify.Notifier.show({
                message: message +  'been created in the selected workspace and project.'
            });
        } else {
            if (successfulRecords.length === 0){
                message = "0 items have been created in the selected workspace and project."
            }

            Rally.ui.notify.Notifier.showWarning({
                message: message + ', but ' + unsuccessfulRecords.length + ' failed: ' + errorMessages.join('<br/>'),
                useHTML: true
            });
        }

        Ext.callback(this.onActionComplete, null, [successfulRecords, unsuccessfulRecords]);
    }
});
Ext.define('CA.technicalservices.BulkMenuItem.xWorkspaceDeepCopy', {
    alias: 'widget.bulkmenuitemxworkspacedeepcopy',
    extend: 'CA.technicalservices.BulkMenuItem.xWorkspaceCopyBase',

    config: {

        text: 'Deep Copy to Workspace...',

        predicate: function (records) {
            //TODO: Make sure that all children are valid to copy
            var linkField = this.workspaceSettings.getCurrentWorkspace().linkField,
                copiedTypes = _.map(this.typesToCopy, function(t){ return t.toLowerCase(); });
            console.log('predicate', this.workspaceSettings.getCurrentWorkspace(), this.typesToCopy);

            return _.every(records, function (record) {
                var type = record.get('_type').toLowerCase();

                if (Ext.Array.contains(copiedTypes, type)){
                    return !record.get(linkField);
                }
                return false;
            });
        }
    },

    _loadRecordsToCopy: function(options){
        var deferred = Ext.create('Deft.Deferred'),
            loader = Ext.create('CArABU.technicalservices.ArtifactLoader',{
                portfolioItemTypes: this.workspaceSettings.getCurrentWorkspace().portfolioItemTypes,
                copyFields: this.copyFields,
                listeners: {
                    loaderror: function(error){
                        deferred.reject(error);
                    },
                    loadcomplete: function(records){
                        deferred.resolve(records);
                    }
                }
            });

        loader.loadHierarchy(this.records);
        return deferred;
    }

});
Ext.define('CA.technicalservices.BulkMenuItem.xWorkspaceCopy', {
    alias: 'widget.bulkmenuitemxworkspacecopy',
    extend: 'CA.technicalservices.BulkMenuItem.xWorkspaceCopyBase',

    config: {
        text: 'Copy to Workspace...',

        predicate: function (records) {
            //TODO: Make sure that all children are valid to copy
            var linkField = this.workspaceSettings.getCurrentWorkspace().linkField,
                copiedTypes = _.map(this.typesToCopy, function(t){ return t.toLowerCase(); });

            console.log('predicate', this.workspaceSettings.getCurrentWorkspace(), this.typesToCopy, linkField);

            return _.every(records, function (record) {
                var type = record.get('_type').toLowerCase();
                console.log('type', type, copiedTypes, record.get(linkField));
                if (Ext.Array.contains(copiedTypes, type)){
                    return !record.get(linkField);
                }
                return false;
            });
        }
    },

    _loadRecordsToCopy: function(){

        var deferred = Ext.create('Deft.Deferred'),
            loader = Ext.create('CArABU.technicalservices.ArtifactLoader',{
                copyFields: this.copyFields,
                listeners: {
                    loaderror: function(error){
                        deferred.reject(error);
                    },
                    loadcomplete: function(records){
                        deferred.resolve(records);
                    }
                }
            });

        loader.load(this.records);
        return deferred;
    }
});
Ext.define('CrossWorkspaceCopier.Settings',{
    singleton: true,



    getFields: function(workspaceSettings){
        console.log('workspaceSettings', workspaceSettings)
        return [{
            name: 'link_field',
            xtype: 'rallyfieldcombobox',
            fieldLabel: 'Link Field',
            model: 'UserStory',
            labelWidth: 200,
            labelAlign: 'right',
            minValue: 0,
            _isNotHidden: function(field) {
                var attribute = field.attributeDefinition;
                if ( field.readOnly == true ) {
                    return false;
                }

                if ( attribute ) {
                    if ( attribute.Constrained == true) {
                        return false;
                    }

                    if ( attribute.AttributeType == "STRING" ) {
                        //console.log(field.name,attribute.AttributeType,field);
                        return true;
                    }
                }
                return false;
            }
        },{
            xtype: 'workspacesettingsform',
            name: 'workspaceSettings',
            workspaceSettings: workspaceSettings,
            fieldLabel: 'Configure workspaces available for copy and mappings',
            labelAlign: 'top',
            margin: '25 0 0 0',
          //  readyEvent: 'ready'
        }];
    }
});

Ext.define('CArABU.technicalservices.WorkspaceConfigurationDialog', {
    extend: 'Rally.ui.dialog.Dialog',
    alias: 'widget.workspaceconfigdialog',

    height: 400,
    width: 400,
    layout: 'fit',
    closable: true,
    draggable: true,

    config: {
        /**
         * @cfg {String}
         * Title to give to the dialog
         */
        title: 'Choose an Item',

        /**
         * @cfg {Boolean}
         * Allow multiple selection or not
         */
        multiple: true,

        /**
         * @cfg {Object}
         * An {Ext.data.Store} config object used when building the grid
         * Handy when you need to limit the selection with store filters
         */
        storeConfig: {
            context: {
                project: null
            },
            sorters: [
                {
                    property: 'FormattedID',
                    direction: 'DESC'
                }
            ]
        },

        /**
         * @cfg {Ext.grid.Column}
         * List of columns that will be used in the chooser
         */
        columns: [
            {
                text: 'ID',
                dataIndex: 'ObjectID',
                renderer: _.identity
            },
            'Name'
        ],

        /**
         * @cfg {String}
         * Text to be displayed on the button when selection is complete
         */
        selectionButtonText: 'Done',

        /**
         * @cfg {Object}
         * The grid configuration to be used when creative the grid of items in the dialog
         */
        gridConfig: {},

        /**
         * @deprecated
         * @cfg {String}
         * The ref of a record to select when the chooser loads
         * Use selectedRecords instead
         */
        selectedRef: undefined,

        /**
         * @cfg {String}|{String[]}
         * The ref(s) of items which should be selected when the chooser loads
         */
        selectedRecords: undefined,

        /**
         * @cfg {Array}
         * The records to select when the chooser loads
         */
        initialSelectedRecords: undefined,

        /**
         * @private
         * @cfg userAction {String} (Optional)
         * The client metrics action to record when the user makes a selection and clicks done
         */

        /**
         * @cfg showRadioButtons {Boolean}
         */
        showRadioButtons: true,

        introText:  "Please select a workspace, Link Field and appropriate mappings for each mapping type in the selected workspace.",

    },
    constructor: function(config) {

        this.workspaces = config.workspaces;
        this.workspaceConfig = config.workspaceConfig || {};
        if (config.selectedWorkspaceStore){
            this.selectedWorkspaceStore = config.selectedWorkspaceStore
        }

        this.mergeConfig(config);
        this.callParent([this.config]);
    },

    initComponent: function() {
        this.callParent(arguments);

        this.addEvents(
            /**
             * @event artifactchosen
             * Fires when user clicks done after choosing an artifact
             * @param {Rally.ui.dialog.ArtifactChooserDialog} source the dialog
             * @param {Rally.data.wsapi.Model}| {Rally.data.wsapi.Model[]} selection selected record or an array of selected records if multiple is true
             */
            'saveconfiguration'
        );

        this.addCls(['chooserDialog', 'chooser-dialog']);
    },

    destroy: function() {
        //      this._destroyTooltip();
        this.callParent(arguments);
    },
    /**
     * getConfiguration
     * returns the configuration currently in the dialog
     */
    getConfiguration: function(){
       return {};
    },
    beforeRender: function() {
        this.callParent(arguments);

        this.addDocked({
            xtype: 'toolbar',
            dock: 'bottom',
            padding: '0 0 10 0',
            layout: {
                type: 'hbox',
                pack: 'center'
            },
            ui: 'footer',
            items: [
                {
                    xtype: 'rallybutton',
                    itemId: 'doneButton',
                    text: this.selectionButtonText,
                    cls: 'primary rly-small',
                    scope: this,
                    disabled: false,
                    userAction: 'clicked done in dialog',
                    handler: this._done
                },
                {
                    xtype: 'rallybutton',
                    text: 'Cancel',
                    cls: 'secondary rly-small',
                    handler: this.close,
                    scope: this,
                    ui: 'link'
                }
            ]
        });

        if (this.introText) {
            this.addDocked({
                xtype: 'component',
                itemId: 'intro-text',
                componentCls: 'intro-panel',
                html: this.introText
            });
        }

        this.addDocked({
            xtype: 'toolbar',
            itemId: 'workspaceSelector',
            dock: 'top',
            layout: 'vbox',
            border: false,
            padding: '0 0 10px 0',
            items: this.getWorkspaceSelectorItems()
        });
    },
    _done: function(){
        var linkField = this.down('#cb-linkField') && this.down('#cb-linkField').getValue(),
            intro = this.down('#intro-text');
        console.log('intro', intro, linkField);

        this._saveMappings();
        this.selectedWorkspaceStore.setLinkField(linkField);

       var validationErrors = this.selectedWorkspaceStore.validateConfiguration(this._getTotalPortfolioItemLevels());
        if (validationErrors && validationErrors.length > 0){
            intro.update('<div class="warning">' + validationErrors.join('<br/>') + '</div>');
            return;
        }
        this.fireEvent('saveconfiguration', this.selectedWorkspaceStore);
        this.close();
    },
    /**
     * Get the records currently selected in the dialog
     * {Rally.data.Model}|{Rally.data.Model[]}
     */
    getSelectedRecords: function() {
        return this.multiple ? this.selectionCache : this.selectionCache[0];
    },

    getWorkspaceSelectorItems: function() {
        var width = 300,
            disabled = this.selectedWorkspaceStore && this.selectedWorkspaceStore.ObjectID > 0;
        console.log('getworkspaceselectoritems');
        return [{
            xtype:'rallycombobox',
            itemId: 'cb-workspace',
            fieldLabel: 'Workspace',
            labelAlign: 'right',
            store: Ext.create('Rally.data.custom.Store',{ data: this.workspaces }),
            displayField: 'Name',
            valueField: 'ObjectID',
            allowNoEntry: true,
            noEntryText: 'Select a Workspace...',
            width: width,
            value: this.selectedWorkspaceStore && this.selectedWorkspaceStore.ObjectID,
            disabled: disabled,
            listeners: {
                scope: this,
                select: this._initializeWorkspace,
                ready: this._initializeWorkspace
            }
        },{
            xtype: 'rallycombobox',
            itemId: 'cb-linkField',
            fieldLabel: 'Link Field',
            labelAlign: 'right',
            width: width,
            store: Ext.create('Rally.data.custom.Store',[]),
            displayField: 'displayName',
            valueField: 'name',
            allowNoEntry: false,
            disabled: true
        }];


    },
    _initializeWorkspace: function(cb){
        if (cb && cb.disabled){
            this._initializeDialog(this.selectedWorkspaceStore);
        } else if (cb && cb.getRecord() && cb.getRecord().get('ObjectID') > 0){
            Ext.create('CArABU.technicalservices.WorkspaceStore',{
                workspace: cb.getRecord(),
                listeners: {
                    ready: this._initializeDialog,
                    error: this._initializeDialogWithError,
                    scope: this
                }
            });
        } else {
            this.down('#cb-linkField').bindStore(null);
            this.down('#cb-linkField').setDisabled(true);
            this.down('#cb-mappingType').bindStore(null);
            this.down('#cb-mappingType').setDisabled(true);
        }
    },
    _initializeDialog: function(otherWorkspaceStore){
        this.selectedWorkspaceStore = otherWorkspaceStore || null;
        if (this.selectedWorkspaceStore){
            this._updateLinkFieldSelector(this.selectedWorkspaceStore);
            this._buildMappingGrid(this.selectedWorkspaceStore);
        }
    },
    _initializeDialogWithError: function(errorMsg){

    },
    _getTotalPortfolioItemLevels: function(){
        var currentWorkspaceStore = this.workspaceSettings.getCurrentWorkspace();

        if (this.selectedWorkspaceStore){
            return Math.min(currentWorkspaceStore.getPortfolioItemLevels(), this.selectedWorkspaceStore.getPortfolioItemLevels());
        }
        return currentWorkspaceStore.getPortfolioItemLevels();
    },
    _updateLinkFieldSelector: function(otherWorkspaceStore){
        var store = Ext.create('Rally.data.custom.Store',{
            data: otherWorkspaceStore.getValidLinkFields()
        });
        this.down('#cb-linkField').bindStore(store);
        this.down('#cb-linkField').setDisabled(false);
        if (this.selectedWorkspaceStore.linkField){
            this.down('#cb-linkField').setValue(this.selectedWorkspaceStore.linkField);
        }
    },
    _saveMappings: function(){
        var otherWorkspace = this.selectedWorkspaceStore,
            grid = this.down('rallygrid');

        if (grid && otherWorkspace){

            Ext.Array.each(grid.getStore().getRange(), function(r){
                otherWorkspace.saveMapping(r.get('type'), 'State', r.get('mapFrom'), r.get('mapTo'));
            });
        }
    },
    _buildMappingGrid: function(){
        var currentWorkspace = this.workspaceSettings.getCurrentWorkspace(),
            otherWorkspace = this.selectedWorkspaceStore,
            totalPortfolioLevels = Math.min(currentWorkspace.getPortfolioItemLevels(), otherWorkspace.getPortfolioItemLevels());
        console.log('_buildMappingGrid', otherWorkspace);
        var data = [];
        for (var i=0; i < totalPortfolioLevels; i++){
            var type = currentWorkspace.portfolioItemTypes[i];
            Ext.Array.each(currentWorkspace.portfolioItemStates[type], function(state){
                var stateName = state && state.get('StringValue').length > 0 && state.get('StringValue') ;
                if (stateName) {
                    var mappedStateName = otherWorkspace.mappings &&
                        otherWorkspace.mappings[type] &&
                        otherWorkspace.mappings[type]['State'] &&
                        otherWorkspace.mappings[type]['State'][stateName] || "";
                    console.log('_buildMappingGrid', mappedStateName);

                    data.push({
                        type: type,
                        mapFrom: stateName,
                        mapTo: mappedStateName
                    });
                }
            });

        }

        this.add({
            xtype: 'rallygrid',
            store: Ext.create('Rally.data.custom.Store',{
                data: data
            }),
            showRowActionsColumn: false,
            showPagingToolbar: false,
            columnCfgs: this._getMappingGridColumnCfgs( otherWorkspace.getPortfolioStates(type))
        });
    },
    _getMappingGridColumnCfgs: function(mapToStateOptions){

        return [{
            dataIndex: 'type',
            text: 'type',
            renderer: function(v){
                return v.replace('PortfolioItem/','');
            }
        },{
            dataIndex: 'mapFrom',
            text: 'Map From'
        },{
            dataIndex: 'mapTo',
            text: 'Map To',
            editor: {
                    xtype: 'rallycombobox',
                    allowNoEntry: true,
                    store: Ext.create('Rally.data.custom.Store',{
                        data: mapToStateOptions
                    }),
                    valueField: 'state',
                    displayField: 'state'
                }
        }];
    }
});

Ext.define('CA.technicalservices.xWorkspaceCopyDialog',{
    extend: 'Rally.ui.dialog.Dialog',

    height: 400,
    width: 600,
    layout: 'fit',
    closable: true,
    draggable: true,


    constructor: function(config) {
        this.mergeConfig(config);

        this.callParent([this.config]);
    },
    initComponent: function() {
        this.callParent(arguments);

        this.addEvents(
            /**
             * @event optionschosen
             * Fires when user clicks done after choosing a project and other options
             * @param {Rally.ui.dialog.ArtifactChooserDialog} source the dialog
             * @param {Rally.data.wsapi.Model}| {Rally.data.wsapi.Model[]} selection selected record or an array of selected records if multiple is true
             */
            'optionschosen'
        );

    },
    getOptions: function(){
        return {};
    },
    beforeRender: function() {
        this.callParent(arguments);

        this.selectedProject = null;

        this.addDocked({
            xtype: 'toolbar',
            dock: 'bottom',
            padding: '0 0 10 0',
            layout: {
                type: 'hbox',
                pack: 'center'
            },
            ui: 'footer',
            items: [
                {
                    xtype: 'rallybutton',
                    cls: 'primary rly-small',
                    disabled: true,
                    handler: function() {
                        this.fireEvent('optionschosen', this.getOptions());
                        this.close();
                    },
                    itemId: 'doneButton',
                    scope: this,
                    text: "Done",
                    userAction: 'clicked done item in dialog'
                },
                {
                    xtype: 'rallybutton',
                    text: 'Cancel',
                    cls: 'secondary rly-small',
                    handler: this.close,
                    scope: this,
                    ui: 'link'
                }
            ]
        });

        if (this.introText) {
            this.addDocked({
                xtype: 'component',
                componentCls: 'intro-panel',
                html: this.introText,
                dock: 'top'
            });
        }

        var workspaces = this.workspaceSettings.getDestinationWorkspaces();

        var filters = _.map(workspaces, function(w){ return { property: "ObjectID", value: w.ObjectID}; });
        filters = Rally.data.wsapi.Filter.or(filters);
        filters = filters.and({
            property: 'State',
            value: 'Open'
        });
        filters = filters.and({
            property: 'Projects.State',
            value: 'Open'
        });

        var pt = this.add({
            xtype: 'rallyprojecttree',
            itemId: 'prjTree',
            border: false,
            autoScroll: true,
            topLevelStoreConfig: {
                fetch: ['Name', 'State'],
                filters: filters,
                sorters: [{
                    property: 'Name',
                    direction: 'ASC'
                }],
                context: {
                    workspace: 'null',
                    project: undefined
                }
            }
        });
        pt.on('itemselected', this.projectSelected, this);

        this.add({
            xtype: 'rallycheckboxfield',
            itemId: 'optionsCopyHierarchy',
            fieldLabel: 'Copy Entire Hierarchy'
        });

    },
    projectSelected: function(treeItem){
        this.selectedProject = treeItem && treeItem.getRecord() || null;
        this.down('#doneButton').setDisabled(this.selectedProject === null);
    },
    getOptions: function(){
        var copyHierarchy = this.down('#optionsCopyHierarchy') && this.down('#optionsCopyHierarchy').getValue() || false;
        return {
            project: this.selectedProject,
            copyHierarchy: copyHierarchy || false,
            records: this.records
        };
    }


});
Ext.define('CArABU.technicalservices.WorkspaceSettingsForm',{
    extend: 'Ext.form.field.Base',
    alias: 'widget.workspacesettingsform',
    fieldSubTpl: '<div id="{id}" class="settings-grid"></div>',
    width: '100%',
    cls: 'column-settings',

    store: undefined,
    mixins: {
        observable: 'Ext.util.Observable'
    },
    constructor: function(config){
        this.mixins.observable.constructor.call(this, config);
        this.callParent(arguments);
    },
    onDestroy: function() {
        if (this._grid) {
            this._grid.destroy();
            delete this._grid;
        }
        this.callParent(arguments);
    },
    initComponent: function(){
        this.callParent();
        this.addEvents('ready');

        if (this.rendered){
            this._buildWorkspaceGrid()
        } else {
            this.on('render', this._buildWorkspaceGrid, this);
        }
    },
    _buildWorkspaceGrid: function(records, operation, success){
        var data = [],
            empty_text = "No destination workspaces configured.";

        Ext.Object.each(this.workspaceSettings.getDestinationWorkspaces(), function(key, wk){
            data.push(wk);
        });

        var custom_store = Ext.create('Ext.data.Store', {
            fields: CArABU.technicalservices.WorkspaceStore.getSettingsDataFields(),
            data: data
        });

        this._grid = Ext.create('Rally.ui.grid.Grid', {
            autoWidth: true,
            renderTo: this.inputEl,
            columnCfgs: this._getColumnCfgs(),
            showRowActionsColumn: false,
            showPagingToolbar: false,
            store: custom_store,
            maxHeight: 300,
            margin: '20 0 0 0',
            emptyText: empty_text,
            editingConfig: {
                publishMessages: false
            }
        });

        Ext.create('Rally.ui.Button',{
            text: 'Add Workspace...',
            renderTo: this.inputEl,
            margin: '10 0 0 0',
            listeners: {
                scope: this,
                click: this._addWorkspace
            }
        });


        var width = Math.max(this.inputEl.getWidth(true),300);

        this.fireEvent('ready', true);

    },
    _addWorkspace: function(){

        if (this.workspaces){
            this._showWorkspaceDialog(this.workspaces);
        } else {
            CArABU.technicalservices.WsapiToolbox.fetchWorkspaces().then({
                success: this._showWorkspaceDialog,
                failure: this._showError,
                scope: this
            });
        }
    },
    _showWorkspaceDialog: function(workspaces, selectedWorkspaceStore){
        this.workspaces = workspaces;
        var width = this.getWidth();

        var cfg = Ext.create('CArABU.technicalservices.WorkspaceConfigurationDialog', {
            autoShow: true,
            maxHeight: 400,
            maxWidth: 400,
            workspaces: workspaces,
            selectedWorkspaceStore: selectedWorkspaceStore,
            workspaceSettings: this.workspaceSettings,
            width: Math.min(width, 400),
            title: 'Add Workspace'
        });
        cfg.on('saveconfiguration', this._saveConfiguration, this);
    },
    _saveConfiguration: function(workspaceStore){
        this._grid.getStore().add(workspaceStore);
        this.workspaceSettings.add(workspaceStore);
    },
    _showError: function(msg){
        //TODO add error text
    },

    _removeWorkspace: function(){
        this.grid.getStore().remove(this.record);
    },
    _getColumnCfgs: function() {
        var me = this;

        var columns = [{
            xtype: 'rallyrowactioncolumn',
            rowActionsFn: function (record) {
                return [
                    {
                        xtype: 'rallyrecordmenuitem',
                        record: record,
                        text: "Edit...",
                        handler: function(){
                            var objId = record.get('ObjectID');
                            me._showWorkspaceDialog(me.workspaces, me.workspaceSettings.getWorkspaceByID(objId));
                         },
                         scope: me
                    },{
                        xtype: 'rallyrecordmenuitem',
                        record: record,
                        text: 'Delete',
                        handler: function(){
                            var objId = record.get('ObjectID');
                            console.log('delete', objId);
                            record.destroy();
                            me.workspaceSettings.removeWorkspace(objId);
                        },
                        scope: me
                    }
                ];
            }
        },{
            text: 'Workspace',
            dataIndex: 'Name',
            flex: 1,
            editor: false
        },{
            text: 'Link Field',
            dataIndex: 'linkField'
        }];
        return columns;
    },
    /**
     * When a form asks for the data this field represents,
     * give it the name of this field and the ref of the selected project (or an empty string).
     * Used when persisting the value of this field.
     * @return {Object}
     */
    getSubmitData: function() {
        var data = {};
        data[this.name] = this.workspaceSettings.getEncodedValue();
        return data;
    },
    getErrors: function() {
        var errors = [];
        //Add validation here
        return errors;
    }
});

Ext.define('CArABU.technicalservices.WorkspaceSettings',{
    context: null,
    syncFields: {
        hierarchicalrequirement: ['Name','Description','ScheduleState'],
        task: ['Name','Description','State'],
        portfolioitem: ['Name','State','Description','PlannedStartDate','PlannedEndDate']
    },
    //workspaces: [{
    //    ObjectID: 42919581370,
    //    _ref: '/workspace/42919581370',
    //    linkField: "c_ExternalID",
    //    projectIDs: [],
    //    portfolioItemTypes: null
    //},{
    //    ObjectID: 34702617071,
    //    _ref: '/workspace/34702617071',
    //    projectIDs: [34702617160],
    //    linkField: "c_ExternalID",
    //    portfolioItemTypes: ['portfolioitem/feature','portfolioitem/initiative'],
    //    mappings: {
    //        "portfolioitem/feature": {
    //            "State": {
    //                "Discovering":"/state/34702617464",
    //                "Developing":"/state/34702617466",
    //                "Measuring":"/state/34702617468",
    //                "Done":"/state/34702617470"
    //            }
    //        },
    //        "portfolioitem/initiative": {
    //            "State": {
    //                "Discovering":"/state/34702617478",
    //                "Developing":"/state/34702617480",
    //                "Measuring":"/state/34702617482",
    //                "Done":"/state/34702617484"
    //            }
    //        }
    //    }
    //}],
    mixins: {
        observable: 'Ext.util.Observable'
    },
    constructor: function(config){
        this.context = config.context;

        this.mixins.observable.constructor.call(this, config);

        this.addEvents(
            'ready',
            'onerror'
        );
    },
    getEncodedValue: function(){
        var encodedValue = {};
        Ext.Object.each(this.workspaceStores, function(objectID, wksp){
            encodedValue[objectID] = wksp;
        });

        return encodedValue;
    },
    initialize: function(settings, currentWorkspaceLinkField){
        if (!settings){
            settings = {};
        }

        this._initializeWorkspaces(settings, currentWorkspaceLinkField).then({
            success: function(){
                this.fireEvent('ready');
            },
            failure: function(msg){
                this.fireEvent('onerror', msg);
            },
            scope: this
        });
    },
    getSyncFields: function(type){
        type = type.toLowerCase();
        if (/^portfolioitem/.test(type)){
            type = 'portfolioitem';
        }
        return this.syncFields[type];
    },
    getMappedValue: function(field, sourceRecord, targetRecord){
        var targetWorkspaceOid = targetRecord.get('Workspace').ObjectID,
            sourceWorkspaceOid = sourceRecord.get('Workspace').ObjectID,
            otherWorkspace = null,
            fromCurrent = true;

        if (sourceWorkspaceOid === this.getCurrentWorkspace().ObjectID){
            otherWorkspace = this.getWorkspaceByID(targetWorkspaceOid);
        } else {
            fromCurrent = false;
            otherWorkspace = this.getWorkspaceByID(sourceWorkspaceOid);
        }

        return otherWorkspace.getMappedValue(sourceRecord.get('type'), field, sourceRecord.get(field), fromCurrent);
    },
    add: function(workspaceStore){
        if (!this.workspaceStores){
            this.workspaceStores = {};
        }
        console.log('add', this.workspaceStores);
        this.workspaceStores[workspaceStore.ObjectID] = workspaceStore;
    },
    _initializeWorkspaces: function(settings,currentWorkspaceLinkField){

        var deferred = Ext.create('Deft.Deferred'),
            currentWkspOid = this.context.getWorkspace().ObjectID;

        var promises = [this._initializeWorkspace(this.context.getWorkspace())];
        Ext.Object.each(settings, function(wkspOid, wksp){
            if (Number(wkspOid) !== currentWkspOid){
                promises.push(this._initializeWorkspace(wksp))
            }
        }, this);

        Deft.Promise.all(promises).then({
            success: function(workspaces){
                Ext.Array.each(workspaces, function(w){
                    this.add(w);
                }, this);
                this.getCurrentWorkspace().linkField = currentWorkspaceLinkField;
                deferred.resolve();
            },
            failure: function(msg){
                deferred.reject(msg);
            },
            scope: this
        });

        return deferred;

    },
    _initializeWorkspace: function(workspace){
        var deferred = Ext.create('Deft.Deferred');
        Ext.create('CArABU.technicalservices.WorkspaceStore',{
            workspace: workspace,
            listeners: {
                ready: function(workspace){
                    deferred.resolve(workspace);
                },
                error: function(msg){
                    deferred.reject(msg);
                }
            }
        });
        return deferred;
    },
    getCurrentContext: function(){
        return this.context;
    },
    removeWorkspace: function(objectID){
        delete this.workspaceStores[objectID];
    },
    getCurrentWorkspace: function(){
        var wksp = this.getWorkspaceByID();
        return wksp;
    },
    getLinkField: function(workspaceID){
        var wksp = this.getWorkspaceByID(workspaceID);
        return wksp && wksp.linkField;
    },
    getWorkspaceByID: function(workspaceID){
        if (!workspaceID){
            workspaceID = this.context.getWorkspace().ObjectID;
        }
        return this.workspaceStores && this.workspaceStores[workspaceID] || null;
    },
    getValueMap: function(workspaceRef, type, field){
        var workspaceID = Rally.util.Ref.getOidFromRef(workspaceRef),
            wksp = this.getWorkspaceByID(workspaceID);

        return wksp.mappings && wksp.mappings[type.toLowerCase()] && wksp.mappings[type.toLowerCase()][field] || null;
    },
    getDestinationWorkspaces: function(){
        var currentWorkspaceID = this.getCurrentWorkspace().ObjectID;
        var workspaces = [];
        Ext.Object.each(this.workspaceStores, function(wOid, w){
            console.log('each wk', wOid, w);
            if (Number(wOid) !== Number(currentWorkspaceID)){
                workspaces.push(w);
            }
        });
        return workspaces;
    },
    getCopyableTypes: function(type){
        var piTypes = this.getCurrentWorkspace().portfolioItemTypes,
            types = [];
        for (var i=0; i<piTypes.length; i++){
            types.push(piTypes[i]);
            if (piTypes[i].toLowerCase === type.toLowerCase()){
                i = piTypes.length;
            }
        }
        types = types.concat(['hierarchicalrequirement','task']);
        return types;
    },
    getWorkspaceForProject: function(projectID){
        var workspaceID = null;
        Ext.Object.each(this.workspaceStores, function(wOid, w){
            console.log('w', w, w.projectIDs, projectID);
            if (w.projectIDs && Ext.Array.contains(w.projectIDs, Number(projectID))){
                workspaceID = w.ObjectID;
                return false;
            }
        });
        return workspaceID;
    }
});

Ext.define('CArABU.technicalservices.WorkspaceStore',{

    mixins: {
        observable: 'Ext.util.Observable'
    },

    /**
     * Configurations
     * @param config
     *
     * workspace
     * ObjectID
     * models
     * linkField
     * portfolioItemTypes
     * portfolioItemStates
     * mappings
     */

    //    ObjectID: 34702617071,
    //    _ref: '/workspace/34702617071',
    //    projectIDs: [34702617160],
    //    linkField: "c_ExternalID",
    //    portfolioItemTypes: ['portfolioitem/feature','portfolioitem/initiative'],
    //    mappings: {
    //        "portfolioitem/feature": {
    //            "State": {
    //                "Discovering":"/state/34702617464",
    //                "Developing":"/state/34702617466",
    //                "Measuring":"/state/34702617468",
    //                "Done":"/state/34702617470"
    //            }
    //        },
    //        "portfolioitem/initiative": {
    //            "State": {
    //                "Discovering":"/state/34702617478",
    //                "Developing":"/state/34702617480",
    //                "Measuring":"/state/34702617482",
    //                "Done":"/state/34702617484"
    //            }
    //        }
    //    }

    constructor: function(config){
        console.log('config', config);
        this._ref = config.workspace._ref || config.workspace.get('_ref');
        this.ObjectID = config.workspace.ObjectID || config.workspace.get('ObjectID');
        this.Name = config.workspace.Name || config.workspace.get('Name');

        this.mixins.observable.constructor.call(this, config);

        Deft.Chain.sequence([
            this._fetchModels,
            this._fetchStateAllowedValues
        ],this).then({
            success: function(){
                this.fireEvent('ready', this);
            },
            failure: function(msg){
                this.fireEvent('error', msg);
            },
            scope: this
        });
    },
    getData: function(){
        return {
            ObjectID:  this.ObjectID,
            _ref: this._ref,
            linkField: this.linkField,
            portfolioItemTypes: this.portfolioItemTypes,
            mappings: this.mappings || {}
        };
    },
    getLinkField: function(){
        return this.linkField;
    },

    getValidLinkFields: function(){
        //Find the custom string field on each model that can be the link field.
        var validFields = [];
        Ext.Object.each(this.models, function(key, m){
            var fields = [];
            Ext.Array.each(m.getFields(), function(f){
                if (f.custom && f.attributeDefinition
                    && f.attributeDefinition.AttributeType === 'STRING'
                    && !f.readOnly){
                    fields.push(f.name);
                }
            });
            if (validFields.length === 0){
                validFields = fields;
            }
            validFields = _.intersection(fields, validFields);
        });

        var validFieldObjects = [];
        Ext.Array.each(validFields, function(f){
            validFieldObjects.push(this.models['UserStory'].getField(f));
        }, this);

        return validFieldObjects
    },
    setLinkField: function(linkField){
        this.linkField = linkField || null;
    },
    getMappedValue: function(type, field, sourceValue, fromCurrent){
        Ext.Object.each(this.mappings, function(mappingType, mappingFieldObj){
            if (mappingType.toLowerCase() === type.toLowerCase()){
                if (mappingFieldObj[field]){
                    var mappedValue = "";
                    Ext.Object.each(mappingFieldObj[field], function(currentValue, otherValue){
                        if (fromCurrent){
                            if (currentValue === sourceValue){
                                mappedValue = otherValue;
                                return false;
                            }
                        } else {
                            if (otherValue === sourceValue){
                                mappedValue = currentValue;
                                return false;
                            }
                        }
                    });
                    return mappedValue;
                }
            }
        });
        return sourceValue;
    },
    getPortfolioItemLevels: function(){
        return this.portfolioItemTypes.length;
    },
    getPortfolioItemType: function(zeroBasedLevel){
        if (zeroBasedLevel >= 0 && zeroBasedLevel < this.portfolioItemTypes.length) {
            return this.portfolioItemTypes[zeroBasedLevel];
        }
        return null;
    },
    getPortfolioItemLevel: function(type){
        for (var i=0; i<this.portfolioItemTypes.length; i++){
            if (this.portfolioItemTypes[i] === type){
                return i;
            }
        }
        return -1;
    },
    getPortfolioStates: function(type){
        var data = [];
        if (this.portfolioItemStates[type]){
            Ext.Array.each(this.portfolioItemStates[type], function(state){
                if (state && state.get('StringValue')){
                    data.push({
                        _ref: state.get('_ref'),
                        state: state.get('StringValue')
                    });
                }
            });
        }
        return data;
    },

    saveMapping: function(mappedType, mappedField, mapFromValue, mapToValue){
        var mappings = this.mappings || {};

        mappings[mappedType] = mappings[mappedType] || {};
        mappings[mappedType][mappedField] = mappings[mappedType][mappedField] || {};
        mappings[mappedType][mappedField][mapFromValue] = mapToValue;

        this.mappings = mappings;
    },
    /**
     * called from the configuration dialog to validate that the workspace has been fully configured.
     */
    validateConfiguration: function(maxPortfolioLevels){
        var errors = [];

        maxPortfolioLevels = maxPortfolioLevels || this.portfolioItemTypes.length;

        if (!this.linkField){
            errors.push("Please select a link field.");
        }

        for (var i=0; i<maxPortfolioLevels; i++){
            var mappings = this.mappings && this.mappings[this.portfolioItemTypes[i]];
            if (!mappings){
                errors.push("Please provide mappings for " + this.portfolioItemTypes[i]);
            } else {
                Ext.Object.each(mappings, function(field, fieldMapping){
                    Ext.Object.each(fieldMapping, function(mapFrom, mapTo){
                        if (!mapTo || mapTo.length === 0){
                            errors.push("Please select a mapping for " + field + " value " + mapFrom);
                        }
                    });
                });
            }
        }
        return errors;
    },
    _fetchModels: function(){
        var deferred = Ext.create('Deft.Deferred'),
            workspaceRef = this._ref;

        console.log('context', workspaceRef);
        var context = { workspace: workspaceRef, project: null },
            models = ['UserStory','Task'];

        CArABU.technicalservices.WsapiToolbox.fetchPortfolioItemTypes(context).then({
            success: function(portfolioItemTypes){
                var portfolioItemModels = _.map(portfolioItemTypes, function(p){
                    return p.get('TypePath');
                });
                this.portfolioItemTypes = portfolioItemModels;

                models = models.concat(portfolioItemModels);
                Rally.data.ModelFactory.getModels({
                    types: models,
                    context: context,
                    success: function(models){
                        this.models = models;
                        deferred.resolve();
                    },
                    failure: function(errorMsg){
                        deferred.reject(errorMsg);
                    },
                    scope: this
                });
            },
            failure: function(errorMsg){
                deferred.reject(errorMsg);
            },
            scope: this
        });
        return deferred;
    },
    _fetchStateAllowedValues: function(){
        var deferred = Ext.create('Deft.Deferred'),
            promises = [];

        console.log('_fetchStateAllowedValues', this.portfolioItemTypes);
        Ext.Array.each(this.portfolioItemTypes, function(m){
            promises.push(CArABU.technicalservices.WsapiToolbox.fetchAllowedValues(this.models[m],'State'));
        }, this);

        this.portfolioItemStates = {};
        Deft.Promise.all(promises).then({
            success: function(results){
                for (var i=0; i<this.portfolioItemTypes.length; i++){
                    this.portfolioItemStates[this.portfolioItemTypes[i]] = results[i];
                }
                console.log('this.PortoflioItemStates', this.portfolioItemStates);
                deferred.resolve();
            },
            failure: function(msg){
                deferred.reject(msg);
            },
            scope: this
        });
        return deferred;
    },
    statics: {
        getSettingsDataFields: function(){
            return ['ObjectID','Name','linkField','mappings'];
        }
    }
});

Ext.define('CArABU.technicalservices.WsapiToolbox',{
    singleton: true,
    fetchWorkspaces: function(){
        var deferred = Ext.create('Deft.Deferred');
        Ext.create('Rally.data.wsapi.Store', {
            model: 'Subscription',
            fetch: ['Workspaces','Name','ObjectID']
        }).load({
            callback: function(records, operation, success){
                if (success){
                    records[0].getCollection('Workspaces',{
                        fetch: ['ObjectID','Name','State'],
                        limit: 'Infinity',
                        buffered: false
                    }).load({
                        callback: function(workspaces, operation){
                            if (operation.wasSuccessful()){
                                deferred.resolve(workspaces);
                            } else {
                                deferred.reject('Error loading workspace information: ' + operation.error && operation.error.errors.join(','));
                            }
                        }
                    });
                } else {
                    deferred.reject('Error querying Subscription: ' + operation.error && operation.error.errors.join(','));
                }
            },
            scope: this
        });
        return deferred;
    },
    fetchPortfolioItemTypes: function(context){
        var deferred = Ext.create('Deft.Deferred');

        Ext.create('Rally.data.wsapi.Store', {
            model: 'TypeDefinition',
            fetch: ['TypePath', 'Ordinal','Name'],
            context: context,
            filters: [
                {
                    property: 'Parent.Name',
                    operator: '=',
                    value: 'Portfolio Item'
                },
                {
                    property: 'Creatable',
                    operator: '=',
                    value: 'true'
                }
            ],
            sorters: [{
                property: 'Ordinal',
                direction: 'ASC'
            }]
        }).load({
            callback: function(records, operation, success){
                if (success){
                    deferred.resolve(records);
                } else {
                    var error_msg = '';
                    if (operation && operation.error && operation.error.errors){
                        error_msg = operation.error.errors.join(',');
                    }
                    deferred.reject('Error loading Portfolio Item Types:  ' + error_msg);
                }
            }
        });
        return deferred.promise;
    },
    fetchAllowedValues: function(model, field){
        var deferred = Ext.create('Deft.Deferred');
        model.getField(field).getAllowedValueStore().load({
            callback: function(records, operation, success) {
                if (success){
                    deferred.resolve(records);
                } else {
                    console.log('error', operation, model.elementName, field);
                    deferred.reject('Error fetching AllowedValues:  ' + operation.error.errors.join(','));
                }
            }
        });
        return deferred;
    }
});
Ext.define("cross-workspace-list", {
    extend: 'Rally.app.App',
    componentCls: 'app',
    logger: new Rally.technicalservices.Logger(),
    defaults: { margin: 10 },

    integrationHeaders : {
        name : "cross-workspace-list"
    },

    items: [
        {xtype:'container',itemId:'selector_box', layout: 'hbox'},
        {xtype:'container',itemId:'display_box'}
    ],
    config: {
        defaultSettings: {
            fieldsToCopy: ['Name','Description','PlanEstimate','ScheduleState'],
            fieldsToUpdate: ['Name','Description','PlanEstimate','ScheduleState'],
            gridFields: ['FormattedID','Name','ScheduleState','PlanEstimate'],
            copyFields: ['Name','ScheduleState','Description','PlanEstimate','State','PlannedStartDate','PlannedEndDate'],
            //            {
            //    'hierarchicalrequirement': ['Name','ScheduleState','Description','PlanEstimate'],
            //    'task': ['Name','State','Description'],
            //    'portfolioitem': ['Name','State','PlannedStartDate','PlannedEndDate']
            //},
            syncFields: {},
            workspaceSettings: {}
        }
    },

    sourcePortfolioItemTypes: [],
    workspaceSettings: null,

    launch: function() {

        this._initializeWorkspaceSettings()
    },
    /**
     * Initializes the current workspace settings, loading in the link field, as well as the states and
     * portfolio item types.
     * @returns {Deft.Deferred}
     * @private
     */
    _initializeWorkspaceSettings: function(){
        this.workspaceSettings = Ext.create('CArABU.technicalservices.WorkspaceSettings',{
            context: this.getContext()
        });
        this.workspaceSettings.on('ready', this._addSelectors, this);
        this.workspaceSettings.initialize(this.getSetting('workspaceSettings') || {}, this.getSetting('link_field') || "");
    },
    _addSelectors: function() {

        this.down('#display_box').removeAll();

        var destinationWorkspaces = this.workspaceSettings && this.workspaceSettings.getDestinationWorkspaces() || [];
        if (destinationWorkspaces.length === 0  || this.getSetting('link_field') == "") {
            this.down('#display_box').add({
                xtype: 'container',
                html: 'Use the "App Settings..." menu choice to configure this app'
            });
            return;
        }

        var container = this.down('#selector_box');
        var cb = container.add({
            xtype: 'rallycombobox',
            itemId: 'cbType',
            fieldLabel: 'Display Type',
            labelAlign: 'right',
            width: 300,
            margin: 5,
            storeConfig: {
                autoLoad: true,
                model: 'TypeDefinition',
                fetch: ['TypePath','DisplayName','Ordinal'],
                filters: this.getTypeFilters(),
                remoteFilter: true,
                listeners: {
                    load: this._updateView,
                    scope: this
                }
            },
            valueField: 'TypePath',
            displayField: 'DisplayName'
        });
        cb.on('select', this._updateView, this);
        // cb.on('ready', this._updateView, this);

        var btn = container.add({
            xtype: 'rallybutton',
            enableToggle: true,
            itemId: 'btToggleState',
            margin: 5,
            iconCls: 'icon-link'
        });


        var syncBtn = container.add({
            xtype: 'rallybutton',
            itemId: 'btSync',
            iconCls: 'icon-refresh',
            margin: 5
        });

        btn.on('toggle', this._toggleView, this);
        syncBtn.on('click', this._sync, this);

    },
    _toggleView: function(btn){
        var allowSync = !btn.pressed,
            syncBtn = this.getSyncButton();

        this.logger.log('_toggleView', allowSync, syncBtn);

        if (btn.pressed){
            btn.removeCls('primary')
            btn.addCls('secondary')
        } else {
            btn.removeCls('secondary')
            btn.addCls('primary')
        }
        if (syncBtn) { syncBtn.setDisabled(allowSync); }

        this._updateView();
    },
    _updateView: function(){
        var type = this.getArtifactType(),
            showLinkedItems = this.showLinkedItemsOnly();

        this.logger.log('_updateView', type, showLinkedItems);

        //Todo, filter out only synced items...If synced only is on, there are a couple of different behaviors:
        // (1) only show items that are synced (starting at the highest level they are synced) - this will result in a mixed hierarchy
        // (2) only show items for the selected type that are synced. -- this is easiest but need to ask about it....

        Ext.create('Rally.data.wsapi.TreeStoreBuilder').build({
            models: [type],
            enableHierarchy: true,
            fetch: this.getFetchList(type),
            filters: this.getFilters()
        }).then({
            success: this._createTreeGrid,
            scope: this
        });

    },
    _sync: function(){

        var sourceRecords= [], //Todo handle paging
            linkField = this.getWorkspaces().getLinkField();

        this.down('rallygridboard').getGridOrBoard().getStore().each(function(r){
            if (r.get(linkField)){
                sourceRecords.push(r);
            }
        });

        this.logger.log('_sync', sourceRecords);

        var loader = Ext.create('CArABU.technicalservices.ArtifactLoader',{
            portfolioItemTypes: this.workspaceSettings.getCurrentWorkspace().portfolioItemTypes,
            loadLinkedItems: true,
            workspaceSettings: this.getWorkspaces(),
            copyFields: this.getFieldsToCopy().concat(['LastUpdateDate',linkField]),
            listeners: {
                loaderror: function(error){
                    this.logger.log('loaderror',error);
                    Rally.ui.notify.Notifier.showError({message: error});
                },
                loadcomplete: function(records){
                    this.logger.log('loadcomplete',records);
                    this.syncRecords(records);
                },
                scope: this
            }
        });
        loader.loadHierarchy(sourceRecords);

    },

    getLinkField: function(){
        return this.getWorkspaces().getCurrentWorkspace().linkField;
    },
    getGridFields: function(){
        //Todo make sure this is returned as an array in Rally
        return this.getSetting('gridFields') || [];
    },
    getTypeFilters: function(){
        var filters = Rally.data.wsapi.Filter.or([{
            property: 'TypePath',
            value: 'HierarchicalRequirement'
        },{
            property: 'TypePath',
            operator: 'contains',
            value: 'PortfolioItem/'
        }]);
        return filters;
    },
    getArtifactType: function(){
        return this.down('#cbType') && this.down('#cbType').getValue() || null;
    },
    showLinkedItemsOnly: function(){
        return this.down('#btToggleState') && this.down('#btToggleState').pressed;
    },
    getSyncButton: function(){
        return this.down('#btSync');
    },
    getFetchList: function(type){
        //Todo this will come from the workspace mapper or configurations at some point...
        var fetch = ['FormattedID','Name'].concat([this.getLinkField()]);
        if (type === 'HierarchicalRequirement'){
            fetch = fetch.concat['ScheduleState'];
        } else { //Portfolio Items
            fetch = fetch.concat['State','PlannedStartDate','PlannedEndDate'];
        }
        return fetch;
    },
    getColumnCfgs: function(type){
        var cols = ['Name',this.getLinkField()];
        if (type === 'HierarchicalRequirement'){
            cols = cols.concat(['ScheduleState']);
        } else { //Portfolio Items
            cols = cols.concat(['State','PlannedStartDate','PlannedEndDate']);
        }
        this.logger.log('columnCfgs', cols);
        return cols;
    },
    getTypesToCopy: function(type){
        return this.getWorkspaces().getCopyableTypes(type);
    },
    getFieldsToCopy: function(){
        return ['Name','ScheduleState','Description','PlanEstimate','State','PlannedStartDate','PlannedEndDate'];
    },
    getFilters: function(){
        if (this.showLinkedItemsOnly()){
            return [{
                property: this.getLinkField(),
                operator: "contains",
                value: "href"
            }];
        }
        return [];
    },
    getNoDataPrimaryText: function(){
        if (this.showLinkedItemsOnly()){
            return "No linked work items were found.";
        }
        return null;
    },
    getNoDataSecondaryText: function(){
        if (this.showLinkedItemsOnly()){
            return "No linked work items were found for the selected type in the current workspace and project scope.";
        }
        return null;
    },
    getWorkspaces: function(){
        this.logger.log('getWorkspaces', this.sourcePortfolioItemTypes);
        if (!this.workspaceSettings){
            this.workspaceSettings = Ext.create('CArABU.technicalservices.WorkspaceSettings',{
                sourcePortfolioItemTypes: this.sourcePortfolioItemTypes,
                context: this.getContext()
            });
        }
        return this.workspaceSettings;
    },
    _createTreeGrid: function(store){

        var box = this.down('#display_box'),
            type = this.getArtifactType();
        if (!box){
            this.logger.log('No Display Box -- somethings wrong.');
            return;
        }
        box.removeAll();
        store.load();
        box.add({
            xtype: 'rallygridboard',
            context: this.getContext(),
            modelNames: [type],
            toggleState: 'grid',
            gridConfig: {
                store: store,
                storeConfig: {
                   // filters: this.getFilters(),
                    pageSize: 200
                },
                noDataPrimaryText: this.getNoDataPrimaryText(),
                noDataSecondaryText: this.getNoDataSecondaryText(),
                columnCfgs: this.getColumnCfgs(type),
                bulkEditConfig: {
                    items: [{
                        xtype: 'bulkmenuitemxworkspacecopy' ,
                        linkField: this.getLinkField(),
                        typesToCopy: this.getTypesToCopy(type),
                        copyFields: this.getFieldsToCopy(),
                        workspaceSettings: this.getWorkspaces(),
                        context: this.getContext()
                    },{
                        xtype: 'bulkmenuitemxworkspacedeepcopy' ,
                        linkField: this.getLinkField(),
                        typesToCopy: this.getTypesToCopy(type),
                        copyFields: this.getFieldsToCopy(),
                        workspaceSettings: this.getWorkspaces(),
                        context: this.getContext()
                    }]
                }
            },
            //plugins: this._getPlugins(),
            height: this.getHeight()
        });
    },

    syncRecords: function(sourceRecords){
        var syncer = Ext.create('CArABU.technicalservices.ArtifactSyncer',{
            workspaceSettings: this.getWorkspaces(),
            copyFields: this.getFieldsToCopy().concat['LastUpdateDate','Workspace','ObjectID'],
            context: this.getContext(),
            listeners: {
                syncerror: function(error){
                    this.logger.log('syncerror',error);
                    Rally.ui.notify.Notifier.showError({message: error});
                },
                synccomplete: function(records){
                    this.logger.log('synccomplete',records);
                },
                syncstatus: function(status){
                    this.logger.log('syncstatus',status);
                    Rally.ui.notify.Notifier.show({message: status});
                },
                scope: this
            }
        });
        syncer.sync(sourceRecords);
    },
    //_gatherData: function(settings) {
    //    this.down('#display_box').removeAll();
    //
    //    this.logger.log("Settings are:", settings);
    //    var linkField = this.getLinkField();
    //
    //    var model_name = 'UserStory';
    //    var field_names = _.uniq(['FormattedID'].concat(this.fieldsToCopy).concat([linkField]).concat(this.fieldsToUpdate));
    //    this.logger.log('_gatherData',field_names, linkField);
    //
    //    var filters = [{property:linkField, operator:'contains', value: 'href' }];
    //
    //    Ext.create('Rally.data.wsapi.Store',{
    //        model: model_name,
    //        fetch: field_names,
    //        filters: filters,
    //        autoLoad: true,
    //        listeners: {
    //            scope: this,
    //            load: function(store, records, success){
    //                this.logger.log('store',store, records);
    //                var fields = this.getGridFields().concat(linkField);
    //                this._displayGrid(store,fields,linkField);
    //            }
    //        }
    //    });
    //},
    //
    //_displayGrid: function(store,field_names, link_field){
    //
    //    if (this.down('#link-grid')){
    //        this.down('#link-grid').destroy();
    //    }
    //
    //    var field_names = ['FormattedID','Name','ScheduleState'].concat(link_field);
    //
    //    var columnCfgs = [];
    //
    //    _.each(field_names, function(f){
    //        if (f == link_field){
    //            columnCfgs.push({
    //                dataIndex: f,
    //                text: f
    //            });
    //        } else {
    //            columnCfgs.push({dataIndex: f, text: f});
    //        }
    //    }, this);
    //
    //    this.down('#display_box').add({
    //        xtype: 'rallygrid',
    //        itemId: 'link-grid',
    //        store: store,
    //        columnCfgs: columnCfgs,
    //        showRowActionsColumn: false
    //    });
    //},
//    _launchCopyDialog: function() {
//
//        var filters = [{property:this.link_field, value: null }];
//        var fetch = [this.link_field].concat(this.fieldsToCopy);
//        this.logger.log('_launchCopyDialog',  this.fieldsToCopy, fetch);
//
//        Ext.create('Rally.technicalservices.dialog.CopyDialog', {
//            artifactTypes: ['userstory'],
//            storeConfig: {
//                fetch: fetch,
//                filters: filters,
//                context: {
//                    workspace: this.getContext().getWorkspace()._ref,
//                    project: this.getContext().getProject()._ref,
//                    projectScopeDown: this.getContext().getProjectScopeDown()
//                }
//            },
//            autoShow: true,
//            height: 400,
//            title: 'Copy',
//            introText: 'Choose a target workspace/project and search for a story to copy',
//            multiple: false,
//            listeners: {
//                artifactchosen: function(dialog, selection){
//                    // {selectedRecords: x, targetProject: y, targetWorkspace: z }
//                    // selectedRecords is a model.  (In an array if multiple was true)
//                    // targetproject, targetworkspace are hashes (do not respond to .get('x'), but to .x
//                    this.logger.log('selected:',selection);
//
//                    var copier = Ext.create('Rally.technicalservices.artifactCopier',{
//                        fieldsToCopy: this.fieldsToCopy,
//                        linkField: this.getSetting('link_field'),
//                        context: this.getContext(),
//                        listeners: {
//                            scope: this,
//                            artifactcreated: function(newArtifact){
//                                console.log('artifactcreated',newArtifact);
////                                this.down('#link-grid').getStore().reload();
//                                Rally.ui.notify.Notifier.showCreate({artifact: newArtifact});
//                            },
//                            copyerror: function(error_msg){
//                                Rally.ui.notify.Notifier.showError({message: error_msg});
//                            },
//                            artifactupdated: function(originalArtifact){
//                                this.logger.log('artifactupdated', originalArtifact);
//                                Rally.ui.notify.Notifier.showUpdate({artifact: originalArtifact});
//                                this.down('#link-grid').getStore().reload();
//                            },
//                            updateerror: function(msg){
//                                this.logger.log('updateerror',msg);
//                                Rally.ui.notify.Notifier.showError({message: msg});
//                            }
//                        }
//                    });
//                    copier.copy(selection.targetWorkspace, selection.targetProject, selection.selectedRecords);
//                },
//                scope: this
//            }
//        });
//    },
    getSettingsFields: function(){
        return CrossWorkspaceCopier.Settings.getFields(this.workspaceSettings);
    },
    
    getOptions: function() {
        return [
            {
                text: 'About...',
                handler: this._launchInfo,
                scope: this
            }
        ];
    },
    
    _launchInfo: function() {
        if ( this.about_dialog ) { this.about_dialog.destroy(); }
        this.about_dialog = Ext.create('Rally.technicalservices.InfoLink',{});
    },
    
    isExternal: function(){
        return typeof(this.getAppId()) == 'undefined';
    },
    
    //onSettingsUpdate:  Override
    onSettingsUpdate: function (settings){
        this.logger.log('onSettingsUpdate',settings, this.workspaceSettings);
        // Ext.apply(this, settings);
        this._initializeWorkspaceSettings();
    }
});

            
               Rally.launchApp('cross-workspace-list', {
                   name: 'Cross Workspace List'
               });
        });
    </script>
    
    <style type="text/css">

.app {
}
.tsinfolink {
    position:absolute;
    right:0px;
    width: 14px;
    height: 14px;
    border-radius: 7px;
    text-align: center;
    color: white;
    background: #C0C0C0;
    border-style: solid;
    border-width: 1px;
    margin-top: 25px;
    margin-right: 5px;
    cursor: pointer;
}

.warning {
    color: red;
}
    </style>

</head>
<body></body>
</html>